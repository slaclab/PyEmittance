{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>PyEmittance is a tool for the adaptive measurement of beam emittance (e.g. of an electron beam at OTR/YAG beam profile monitors) using a single quadrupole scan developed at SLAC National Accelerator Laboratory. The Twiss parameters and the 'Bmag' match parameter can also be obtained. It can be used in different beamlines/machines by defining machine-specific configuration files. </p> <p>This tool was designed for robustness during online machine learning optimizations where each measurement needs to be reliable. It is still a work in progress, with version 1.0 to be released soon.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-setuptools","title":"Using setuptools","text":"<pre><code>python setup.py install\n</code></pre>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code># From PyPI distribution\npip install pyemittance\n\n# or from the source folder\npip install .\n</code></pre>"},{"location":"examples/config_setup_example/","title":"Config files setup for EPICS systems","text":"<p>NOTE! make sure your files are the only json files in the directory pyemittance/configs/ (delete or remove others).</p> <p>Required files:</p> <ol> <li>beamline_info.json : measurements</li> <li>img_proc.json :  required only if doing OTR image analysis (sigma units in meters, bg_im needs to be the path to the .npy file of the background image array)</li> <li>meas_pv_info.json : required PVs for measurement devices (OTR, wire, quad)</li> </ol> <p>Optionally: 4. savepaths.json : required for defining directories for saving</p> <p>The most important file for the emittance computation is</p> In\u00a0[1]: Copied! <pre>import json\njson.load(open(\"../../pyemittance/configs/LCLS_OTR3/beamline_info.json\"))\n</pre> import json json.load(open(\"../../pyemittance/configs/LCLS_OTR3/beamline_info.json\")) Out[1]: <pre>{'name': 'LCLS',\n 'Lquad': 0.108,\n 'energy': 135000000.0,\n 'Twiss0': [1e-06, 1e-06, 4.68280051, 4.68872767, -1.79636538, -1.79814306],\n 'rMatx': [1, 4.17, 0, 1],\n 'rMaty': [1, 4.17, 0, 1]}</pre> <p>The important params are:</p> <ul> <li>beam_info['Lquad'] : scanning quad effective length [m]</li> <li>beam_info['energy'] : beam energy [eV]</li> <li>beam_info['Twiss0'] : design Twiss at measurement location (e_x, e_y, beta_x, beta_y, alpha_x, alpha_y)</li> <li>beam_info['rMatx'], beam_info['rMaty'] : 2x2 transfer matrices for x, y from scanning to quad to OTR/screen, critical when there is more than a drift (quads, etc) in between, and this r-matrix takes into account those contributions (need to get from external model).</li> </ul> In\u00a0[2]: Copied! <pre>from pyemittance.load_json_configs import load_configs\n</pre> from pyemittance.load_json_configs import load_configs In\u00a0[3]: Copied! <pre>load_configs(\"../../pyemittance/configs/LCLS_OTR3/\")\n</pre> load_configs(\"../../pyemittance/configs/LCLS_OTR3/\") Out[3]: <pre>{'beamline_info': {'name': 'LCLS',\n  'Lquad': 0.108,\n  'energy': 135000000.0,\n  'Twiss0': [1e-06, 1e-06, 4.68280051, 4.68872767, -1.79636538, -1.79814306],\n  'rMatx': [1, 4.17, 0, 1],\n  'rMaty': [1, 4.17, 0, 1]},\n 'img_proc': {'subtract_bg': False,\n  'use_roi': False,\n  'avg_ims': True,\n  'n_to_acquire': 5,\n  'background_im': None,\n  'amp_threshold': 200,\n  'min_sigma': 2e-08,\n  'max_sigma': 0.1,\n  'max_samples': 3,\n  'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}},\n 'meas_pv_info': {'diagnostic': {'pv': {'name': 'OTRS:IN20:621',\n    'image': 'OTRS:IN20:621:IMAGE',\n    'nrow': 'OTRS:IN20:621:ROI_YNP',\n    'ncol': 'OTRS:IN20:621:ROI_XNP',\n    'resolution': 'OTRS:IN20:621:RESOLUTION',\n    'xsize': 'OTRS:IN20:621:XRMS',\n    'ysize': 'OTRS:IN20:621:YRMS'}},\n  'meas_device': {'settle_time': 1,\n   'bounds': [-2, 2],\n   'pv': {'name': 'QUAD:IN20:525',\n    'cntrl': 'QUAD:IN20:525:BCTRL',\n    'read': 'QUAD:IN20:525:BACT'}},\n  'beam_info': {'energy': 'REFS:IN20:751:EDES'}},\n 'savepaths': {'fits': '/home/physics3/ml_tuning/20220803/saved_fits/',\n  'images': '/home/physics3/ml_tuning/20220803/saved_images/',\n  'monitoring': '/home/physics3/ml_tuning/20220803/monitoring/',\n  'summaries': '/home/physics3/ml_tuning/20220803/summaries/',\n  'raw_saves': '/home/physics3/ml_tuning/20220803/raw_saves/',\n  'emit_saves': '/home/physics3/ml_tuning/20220803/emit_saves/',\n  'mon_saves': '/home/physics3/ml_tuning/20220803/mon_saves/',\n  'xopt_saves': '/home/physics3/ml_tuning/20220803/xopt_saves/'}}</pre>"},{"location":"examples/config_setup_example/#config-files-setup-for-epics-systems","title":"Config files setup for EPICS systems\u00b6","text":"<p>This notebook shows what config files you need and how to set them up.</p> <p>Note that this setup will be improved in the future to be only one json files with all machine information, removing the need for different directories</p>"},{"location":"examples/config_setup_example/#load-all-configs","title":"Load all configs\u00b6","text":"<p>This will load all files into a dict</p>"},{"location":"examples/image_analysis/","title":"Image analysis","text":"In\u00a0[1]: Copied! <pre>from pyemittance.image import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from pyemittance.image import Image import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre># get example data\nimage = np.load(\"./saved_images/1618446887_img.npy\", allow_pickle = True)\nncol = np.load(\"./saved_images/1618446887_ncol.npy\", allow_pickle = True)\nnrow = np.load(\"./saved_images/1618446887_nrow.npy\", allow_pickle = True)\n</pre> # get example data image = np.load(\"./saved_images/1618446887_img.npy\", allow_pickle = True) ncol = np.load(\"./saved_images/1618446887_ncol.npy\", allow_pickle = True) nrow = np.load(\"./saved_images/1618446887_nrow.npy\", allow_pickle = True) In\u00a0[3]: Copied! <pre># standard way to reshape the image array\nim = Image(image, ncol, nrow)\nim.reshape_im()\nprofx, profy = im.get_im_projection()\n</pre> # standard way to reshape the image array im = Image(image, ncol, nrow) im.reshape_im() profx, profy = im.get_im_projection() In\u00a0[4]: Copied! <pre>plt.imshow(im.proc_image)\n</pre> plt.imshow(im.proc_image) Out[4]: <pre>&lt;matplotlib.image.AxesImage at 0x7fc8d1e3bdc0&gt;</pre> In\u00a0[5]: Copied! <pre>plt.plot(profx, label=\"x-profile\")\nplt.plot(profy, label=\"y-profile\")\nplt.legend()\n</pre> plt.plot(profx, label=\"x-profile\") plt.plot(profy, label=\"y-profile\") plt.legend() Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x7fc8d1d23b50&gt;</pre> In\u00a0[6]: Copied! <pre># returns: xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude\nfit_res = im.get_sizes(method = \"gaussian\", show_plots = True)\nxsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res\n</pre> # returns: xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude fit_res = im.get_sizes(method = \"gaussian\", show_plots = True) xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res In\u00a0[7]: Copied! <pre>from pyemittance.bs_fitting_methods import fit_gaussian_linear_background\n</pre> from pyemittance.bs_fitting_methods import fit_gaussian_linear_background In\u00a0[8]: Copied! <pre>fit_gaussian_linear_background(profx)\n</pre> fit_gaussian_linear_background(profx) Out[8]: <pre>(array([3217.84266596,  185.43343034,    7.45136337]),\n array([104.61474971,   0.27784605,   0.28365576]))</pre> In\u00a0[9]: Copied! <pre>fit_gaussian_linear_background(profy)\n</pre> fit_gaussian_linear_background(profy) Out[9]: <pre>(array([1991.90020293,  146.34583081,   11.56409756]),\n array([44.4088356 ,  0.29357206,  0.30790032]))</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/image_analysis/#image-analysis","title":"Image analysis\u00b6","text":"<p>example + adding fitting methods</p>"},{"location":"examples/image_analysis/#example-of-how-this-is-called-in-pyemittance","title":"Example of how this is called in pyemittance\u00b6","text":""},{"location":"examples/image_analysis/#gaussian-linear-bg-function-example","title":"Gaussian + linear bg function example\u00b6","text":""},{"location":"examples/image_analysis/#adding-a-fitting-method","title":"Adding a fitting method:\u00b6","text":""},{"location":"examples/image_analysis/#need-to-write-an-asymmetric-gaussian-linear-bg-function-to-import-as","title":"Need to write an asymmetric Gaussian + linear bg function to import as:\u00b6","text":"<p>fit_asym_gaussian_linear_background</p>"},{"location":"examples/image_analysis/#and-to-pass-an-array-like-in-the-cell-above-and-return-a-fit-with-the-results","title":"and to pass an array like in the cell above and return a fit with the results:\u00b6","text":"<p>size (Gaussian width), error on the size, and the amplitude</p>"},{"location":"examples/simulated_epics/","title":"Beam Simulator and EPICS server","text":"In\u00a0[1]: Copied! <pre>from pyemittance.simulation_server import start_server\nfrom pyemittance import print_logging\nimport logging\nprint_logging(level=10)\n\nstart_server(config_name='LCLS2_OTR0H04')\n</pre> from pyemittance.simulation_server import start_server from pyemittance import print_logging import logging print_logging(level=10)  start_server(config_name='LCLS2_OTR0H04') <pre>2023-08-27 17:45:06,276 | INFO : Initialized config: LCLS2_OTR0H04\n2023-08-27 17:45:06,278 | INFO : Serving: ['QUAD:HTR:120:BCTRL', 'QUAD:HTR:120:BACT', 'OTRS:HTR:330:Image:ArrayData', 'OTRS:HTR:330:Image:ArraySize1_RBV', 'OTRS:HTR:330:Image:ArraySize0_RBV', 'OTRS:HTR:330:RESOLUTION', 'sim_screen_sigma_x', 'sim_screen_sigma_y']\n2023-08-27 17:45:16,412 | INFO : Setting QUAD:HTR:120:BCTRL =  -6.0\n2023-08-27 17:45:16,810 | INFO : Setting QUAD:HTR:120:BCTRL =  -4.0\n2023-08-27 17:45:17,111 | INFO : Setting QUAD:HTR:120:BCTRL =  -2.0\n2023-08-27 17:45:17,406 | INFO : Setting QUAD:HTR:120:BCTRL =  0.0\n2023-08-27 17:45:17,702 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.7424975910795275\n2023-08-27 17:45:17,996 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.20208132589960626\n2023-08-27 17:45:18,323 | INFO : Setting QUAD:HTR:120:BCTRL =  0.338334939280315\n2023-08-27 17:45:18,615 | INFO : Setting QUAD:HTR:120:BCTRL =  0.8787512044602364\n2023-08-27 17:45:18,905 | INFO : Setting QUAD:HTR:120:BCTRL =  1.4191674696401575\n2023-08-27 17:45:19,193 | INFO : Setting QUAD:HTR:120:BCTRL =  1.9595837348200786\n2023-08-27 17:45:19,481 | INFO : Setting QUAD:HTR:120:BCTRL =  2.5\n2023-08-27 17:45:19,809 | INFO : Setting QUAD:HTR:120:BCTRL =  -1.823162654966067\n2023-08-27 17:45:20,105 | INFO : Setting QUAD:HTR:120:BCTRL =  -1.102635545805056\n2023-08-27 17:45:20,397 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.3821084366440448\n2023-08-27 17:45:20,687 | INFO : Setting QUAD:HTR:120:BCTRL =  1.0589457816779775\n2023-08-27 17:45:20,974 | INFO : Setting QUAD:HTR:120:BCTRL =  1.7794728908389885\n2023-08-27 17:45:21,315 | INFO : Setting QUAD:HTR:120:BCTRL =  2.9632139415827896\n2023-08-27 17:45:21,607 | INFO : Setting QUAD:HTR:120:BCTRL =  3.5808325303598427\n2023-08-27 17:45:21,896 | INFO : Setting QUAD:HTR:120:BCTRL =  4.198451119136895\n2023-08-27 17:45:22,187 | INFO : Setting QUAD:HTR:120:BCTRL =  4.8160697079139485\n2023-08-27 17:45:22,480 | INFO : Setting QUAD:HTR:120:BCTRL =  3.1175946649951527\n2023-08-27 17:45:22,775 | INFO : Setting QUAD:HTR:120:BCTRL =  3.8587082629893357\n2023-08-27 17:45:23,123 | INFO : Setting QUAD:HTR:120:BCTRL =  4.599821860983519\n2023-08-27 17:45:23,420 | INFO : Setting QUAD:HTR:120:BCTRL =  5.340935458977701\n2023-08-27 17:45:23,710 | INFO : Setting QUAD:HTR:120:BCTRL =  6.082049056971885\n2023-08-27 17:45:24,000 | INFO : Setting QUAD:HTR:120:BCTRL =  6.823162654966067\n2023-08-27 17:45:24,803 | INFO : Setting QUAD:HTR:120:BCTRL =  0.0\n</pre> <pre>\nKeyboardInterrupt\n\n</pre>"},{"location":"examples/simulated_epics/#beam-simulator-and-epics-server","title":"Beam Simulator and EPICS server\u00b6","text":"<p>Run this cell to start the server.</p> <p>Then try on the command line:</p> <pre><code>caput QUAD:HTR:120:BCTRL 1.234\ncaget QUAD:HTR:120:BACT\n</code></pre>"},{"location":"examples/simulated_online/","title":"Online PyEmittance","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pyemittance import PyEmittance, print_logging\nimport numpy as np\nprint_logging() # Print log messages here\n</pre> from pyemittance import PyEmittance, print_logging import numpy as np print_logging() # Print log messages here In\u00a0[3]: Copied! <pre>meas = PyEmittance(config_name='LCLS2_OTR0H04')\nmeas.online = True\n\n# Set some other options\nmeas.add_pnts = False\nmeas.num_points = 7   # only matters if adapt_ranges is used.\nmeas.adapt_ranges = True  # If helping, will ensure there are at least 7 total points\nmeas.check_sym = True\nmeas.infl_check = True\n\nmeas.show_plots = True\n\n# Change quad bounds\nmeas.config_dict['meas_pv_info']['meas_device']['bounds'] = [-6, 8]\n\n# Change settle time\nmeas.config_dict['meas_pv_info']['meas_device']['settle_time'] = 0.1\n\nmeas.config_dict\n</pre> meas = PyEmittance(config_name='LCLS2_OTR0H04') meas.online = True  # Set some other options meas.add_pnts = False meas.num_points = 7   # only matters if adapt_ranges is used. meas.adapt_ranges = True  # If helping, will ensure there are at least 7 total points meas.check_sym = True meas.infl_check = True  meas.show_plots = True  # Change quad bounds meas.config_dict['meas_pv_info']['meas_device']['bounds'] = [-6, 8]  # Change settle time meas.config_dict['meas_pv_info']['meas_device']['settle_time'] = 0.1  meas.config_dict  Out[3]: <pre>{'beamline_info': {'name': 'LCLS2',\n  'species': 'electron',\n  'Lquad': 0.1244,\n  'energy': 80000000.0,\n  'Twiss0': [1e-06, 1e-06, 5.01, 5.01, 0.049, 0.049],\n  'rMatx': [1, 2.2, 0, 1],\n  'rMaty': [1, 2.2, 0, 1]},\n 'img_proc': {'subtract_bg': False,\n  'use_roi': False,\n  'avg_ims': True,\n  'n_to_acquire': 1,\n  'background_im': '/home/physics3/ml_tuning/20220805_LCLS2_inj/example_images/bg_8_6_22.npy',\n  'amp_threshold': 150,\n  'min_sigma': 3,\n  'max_sigma': 700,\n  'max_samples': 1,\n  'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}},\n 'meas_pv_info': {'diagnostic': {'pv': {'name': 'OTRS:HTR:330',\n    'image': 'OTRS:HTR:330:Image:ArrayData',\n    'nrow': 'OTRS:HTR:330:Image:ArraySize1_RBV',\n    'ncol': 'OTRS:HTR:330:Image:ArraySize0_RBV',\n    'resolution': 'OTRS:HTR:330:RESOLUTION',\n    'xsize': 'OTRS:HTR:330:XRMS',\n    'ysize': 'OTRS:HTR:330:YRMS'}},\n  'meas_device': {'settle_time': 0.1,\n   'bounds': [-6, 8],\n   'pv': {'name': 'QUAD:HTR:120',\n    'cntrl': 'QUAD:HTR:120:BCTRL',\n    'read': 'QUAD:HTR:120:BACT'}},\n  'beam_info': {'energy': ''}},\n 'savepaths': {'fits': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/saved_fits/',\n  'images': None,\n  'monitoring': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/monitoring/',\n  'summaries': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/summaries/',\n  'raw_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/raw_saves/',\n  'emit_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/emit_saves/',\n  'mon_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/mon_saves/',\n  'xopt_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/xopt_saves/'}}</pre> In\u00a0[4]: Copied! <pre># Convenience methods.\nmeas.quad_init, meas.quad_bounds\n</pre> # Convenience methods. meas.quad_init, meas.quad_bounds Out[4]: <pre>([-6, -4, -2, 0], [-6, 8])</pre> In\u00a0[5]: Copied! <pre>meas.config_dict.keys()\n</pre> meas.config_dict.keys() Out[5]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[6]: Copied! <pre>meas.config_dict['meas_pv_info']['meas_device']\n</pre> meas.config_dict['meas_pv_info']['meas_device'] Out[6]: <pre>{'settle_time': 0.1,\n 'bounds': [-6, 8],\n 'pv': {'name': 'QUAD:HTR:120',\n  'cntrl': 'QUAD:HTR:120:BCTRL',\n  'read': 'QUAD:HTR:120:BACT'}}</pre> In\u00a0[7]: Copied! <pre>meas.config_dict['img_proc']\n</pre> meas.config_dict['img_proc'] Out[7]: <pre>{'subtract_bg': False,\n 'use_roi': False,\n 'avg_ims': True,\n 'n_to_acquire': 1,\n 'background_im': '/home/physics3/ml_tuning/20220805_LCLS2_inj/example_images/bg_8_6_22.npy',\n 'amp_threshold': 150,\n 'min_sigma': 3,\n 'max_sigma': 700,\n 'max_samples': 1,\n 'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}}</pre> In\u00a0[8]: Copied! <pre>result = meas.measure_emittance()\n</pre> result = meas.measure_emittance() <pre>2023-08-28 01:36:33,868 | INFO : Running online!\n2023-08-28 01:36:33,917 | INFO : EPICS put QUAD:HTR:120:BCTRL = -6\n2023-08-28 01:36:33,945 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:34,963 | INFO : 2023-08-28_01-36-34-963867\n2023-08-28 01:36:35,178 | INFO : EPICS put QUAD:HTR:120:BCTRL = -4\n2023-08-28 01:36:35,180 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:35,670 | INFO : 2023-08-28_01-36-35-670477\n2023-08-28 01:36:35,821 | INFO : EPICS put QUAD:HTR:120:BCTRL = -2\n2023-08-28 01:36:35,822 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:36,325 | INFO : 2023-08-28_01-36-36-325273\n2023-08-28 01:36:36,457 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0\n2023-08-28 01:36:36,459 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:36,903 | INFO : 2023-08-28_01-36-36-903150\n2023-08-28 01:36:37,038 | INFO : Adapting ranges\n2023-08-28 01:36:37,040 | INFO : Adapting ranges for x beam size measurement: [-0.7332507599154842, -0.1943756332629034, 0.34449949338967734, 0.883374620042258, 1.4222497466948387, 1.9611248733474196, 2.5]\n2023-08-28 01:36:37,042 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.7332507599154842\n2023-08-28 01:36:37,043 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:37,484 | INFO : 2023-08-28_01-36-37-484072\n2023-08-28 01:36:37,618 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.1943756332629034\n2023-08-28 01:36:37,621 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:38,125 | INFO : 2023-08-28_01-36-38-125301\n2023-08-28 01:36:38,260 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0.34449949338967734\n2023-08-28 01:36:38,261 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:38,715 | INFO : 2023-08-28_01-36-38-715634\n2023-08-28 01:36:38,855 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0.883374620042258\n2023-08-28 01:36:38,858 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:39,304 | INFO : 2023-08-28_01-36-39-304345\n2023-08-28 01:36:39,434 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.4222497466948387\n2023-08-28 01:36:39,437 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:39,872 | INFO : 2023-08-28_01-36-39-871951\n2023-08-28 01:36:40,000 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.9611248733474196\n2023-08-28 01:36:40,002 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:40,456 | INFO : 2023-08-28_01-36-40-456658\n2023-08-28 01:36:40,589 | INFO : EPICS put QUAD:HTR:120:BCTRL = 2.5\n2023-08-28 01:36:40,590 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:41,127 | INFO : 2023-08-28_01-36-41-127903\n2023-08-28 01:36:41,255 | INFO : Adapting ranges for y beam size measurement: [-1.7710405053208949, -1.0592004211007457, -0.34736033688059664, 0.36447974733955246, 1.0763198315597016, 1.7881599157798507, 2.5]\n2023-08-28 01:36:41,259 | INFO : EPICS put QUAD:HTR:120:BCTRL = -1.7710405053208949\n2023-08-28 01:36:41,261 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:41,705 | INFO : 2023-08-28_01-36-41-705535\n2023-08-28 01:36:41,834 | INFO : EPICS put QUAD:HTR:120:BCTRL = -1.0592004211007457\n2023-08-28 01:36:41,836 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:42,286 | INFO : 2023-08-28_01-36-42-286858\n2023-08-28 01:36:42,419 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.34736033688059664\n2023-08-28 01:36:42,422 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:42,866 | INFO : 2023-08-28_01-36-42-866635\n2023-08-28 01:36:42,995 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.0763198315597016\n2023-08-28 01:36:42,996 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:43,451 | INFO : 2023-08-28_01-36-43-451592\n2023-08-28 01:36:43,579 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.7881599157798507\n2023-08-28 01:36:43,582 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:44,149 | INFO : 2023-08-28_01-36-44-149256\n2023-08-28 01:36:44,150 | INFO : Beam params out of bounds in image 0 out of 1 samples\n2023-08-28 01:36:44,285 | INFO : Checking symmetry\n2023-08-28 01:36:44,287 | INFO : EPICS put QUAD:HTR:120:BCTRL = 2.961892965702212\n2023-08-28 01:36:44,288 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:44,757 | INFO : 2023-08-28_01-36-44-757318\n2023-08-28 01:36:44,894 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.5777502533051617\n2023-08-28 01:36:44,895 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:45,348 | INFO : 2023-08-28_01-36-45-348075\n2023-08-28 01:36:45,475 | INFO : EPICS put QUAD:HTR:120:BCTRL = 4.193607540908111\n2023-08-28 01:36:45,478 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:45,939 | INFO : 2023-08-28_01-36-45-939708\n2023-08-28 01:36:46,073 | INFO : EPICS put QUAD:HTR:120:BCTRL = 4.809464828511061\n2023-08-28 01:36:46,075 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:46,540 | INFO : 2023-08-28_01-36-46-540906\n2023-08-28 01:36:46,676 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.1101486436172707\n2023-08-28 01:36:46,678 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:47,150 | INFO : 2023-08-28_01-36-47-150128\n2023-08-28 01:36:47,418 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.8423270159579954\n2023-08-28 01:36:47,420 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:47,873 | INFO : 2023-08-28_01-36-47-873077\n2023-08-28 01:36:48,002 | INFO : EPICS put QUAD:HTR:120:BCTRL = 4.57450538829872\n2023-08-28 01:36:48,003 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:48,465 | INFO : 2023-08-28_01-36-48-465331\n2023-08-28 01:36:48,603 | INFO : EPICS put QUAD:HTR:120:BCTRL = 5.306683760639444\n2023-08-28 01:36:48,604 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:49,075 | INFO : 2023-08-28_01-36-49-075148\n2023-08-28 01:36:49,208 | INFO : EPICS put QUAD:HTR:120:BCTRL = 6.038862132980169\n2023-08-28 01:36:49,209 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:49,674 | INFO : 2023-08-28_01-36-49-674304\n2023-08-28 01:36:49,811 | INFO : EPICS put QUAD:HTR:120:BCTRL = 6.771040505320894\n2023-08-28 01:36:49,813 | INFO : Settling for 0.1 s...\n2023-08-28 01:36:50,264 | INFO : 2023-08-28_01-36-50-264603\n2023-08-28 01:36:50,391 | INFO : Checking inflection\n2023-08-28 01:36:50,392 | INFO : Emmitance calc for 11 x points, 11 y points\n</pre> In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[10]: Copied! <pre>result\n</pre> result Out[10]: <pre>{'quadvalsx': array([-0.73325076, -0.19437563,  0.34449949,  0.88337462,  1.42224975,\n         1.96112487,  2.5       ,  2.96189297,  3.57775025,  4.19360754,\n         4.80946483]),\n 'beamsizesx': array([5.30669701e-04, 4.16529349e-04, 3.02447902e-04, 1.88725933e-04,\n        8.67880207e-05, 7.49204269e-05, 1.70535720e-04, 2.64482195e-04,\n        3.88012512e-04, 5.14672236e-04, 6.37204151e-04]),\n 'beamsizeserrx': array([0.03232671, 0.02454762, 0.01151363, 0.00631758, 0.00172789,\n        0.00162318, 0.00564142, 0.0094879 , 0.01958493, 0.03025297,\n        0.04030609]),\n 'error_x': False,\n 'emit_x': 6.455155468940672e-09,\n 'norm_emit_x': 1.0105733144794533e-06,\n 'beta_x': 9.884991664691047,\n 'alpha_x': -1.9764682514857934,\n 'emit_x_err': 1.856990887145974e-07,\n 'norm_emit_x_err': 2.9071731034376036e-05,\n 'beta_x_rel_err': 28.76756254874085,\n 'alpha_x_rel_err': -1.7677989091920645e-15,\n 'sigma_11': 6.380915800476337e-08,\n 'sigma_12': 1.2758409842766127e-08,\n 'sigma_22': 3.2040236893413367e-09,\n 'screen_sigma_11': array([2.84388781e-07, 1.73471634e-07, 9.08043228e-08, 3.57132481e-08,\n        7.53363790e-09, 5.60947059e-09, 2.92933968e-08, 6.94914392e-08,\n        1.50939032e-07, 2.63364615e-07, 4.05853403e-07]),\n 'screen_sigma_12': array([ 6.57774573e-08,  3.00413298e-08,  6.68873116e-09, -4.57979099e-09,\n        -4.05973963e-09,  7.95729634e-09,  3.11836073e-08,  5.97982635e-08,\n         1.10132404e-07,  1.74009951e-07,  2.51024483e-07]),\n 'screen_sigma_22': array([1.53604615e-08, 5.44267964e-09, 9.51586378e-10, 1.75406946e-09,\n        7.71878325e-09, 1.87161329e-08, 3.46182589e-08, 5.20567914e-08,\n        8.06339833e-08, 1.15129864e-07, 1.55363881e-07]),\n 'quadvalsy': array([-1.77104051, -1.05920042, -0.34736034,  0.36447975,  1.07631983,\n         1.78815992,  2.5       ,  3.11014864,  3.84232702,  4.57450539,\n         5.30668376,  6.03886213,  6.77104051]),\n 'beamsizesy': array([0.00169463, 0.00150476, 0.00130782, 0.00110941, 0.00090467,\n        0.00070075, 0.00049736, 0.00032057, 0.00012413, 0.00015702,\n        0.00036321, 0.00059043, 0.00081527]),\n 'beamsizeserry': array([4.66318252e-06, 3.56010524e-06, 2.95639842e-06, 2.32580246e-06,\n        1.76869432e-06, 1.04081141e-06, 6.18431011e-07, 3.46567437e-07,\n        8.65385655e-08, 1.30009104e-07, 3.71681684e-07, 7.46160671e-07,\n        1.51397948e-06]),\n 'error_y': False,\n 'emit_y': 1.264551333162616e-08,\n 'norm_emit_y': 1.9796917955459723e-06,\n 'beta_y': 11.120451027918568,\n 'alpha_y': 20.211438005484805,\n 'emit_y_err': 1.824617464729563e-11,\n 'norm_emit_y_err': 2.8564915715212783e-09,\n 'beta_y_rel_err': 0.001442897110527482,\n 'alpha_y_rel_err': 2.396186848885902e-19,\n 'sigma_33': 1.406238117272401e-07,\n 'sigma_34': -2.5558400874969377e-07,\n 'sigma_44': 4.6566149595630123e-07,\n 'screen_sigma_33': array([2.90247191e-06, 2.27285929e-06, 1.71430250e-06, 1.22953159e-06,\n        8.21327759e-07, 4.92523895e-07, 2.46005243e-07, 1.02421635e-07,\n        1.54209091e-08, 2.46000859e-08, 1.33327679e-07, 3.45034349e-07,\n        6.63213669e-07]),\n 'screen_sigma_34': array([ 1.53268735e-06,  1.22575746e-06,  9.49827725e-07,  7.06110679e-07,\n         4.95841721e-07,  3.20279371e-07,  1.80705567e-07,  9.07038654e-08,\n         2.00473667e-08, -8.47925297e-09,  6.62134347e-09,  6.68742936e-08,\n         1.73832878e-07]),\n 'screen_sigma_44': array([8.09410222e-07, 6.61123754e-07, 5.26355540e-07, 4.05644071e-07,\n        2.99538057e-07, 2.08596549e-07, 1.33389071e-07, 8.18879745e-08,\n        3.64314395e-08, 9.42300526e-09, 1.52819879e-09, 1.34249827e-08,\n        4.58039091e-08]),\n 'sqrt_norm_emit_4d': 1.4144340562474709e-06,\n 'sqrt_norm_emit_4d_err': 4.0689820235350726e-05}</pre> In\u00a0[11]: Copied! <pre>plt.plot(result['quadvalsx'], np.sqrt(result['screen_sigma_11']))\nplt.plot(result['quadvalsx'], result['beamsizesx'], marker='x')\n</pre> plt.plot(result['quadvalsx'], np.sqrt(result['screen_sigma_11'])) plt.plot(result['quadvalsx'], result['beamsizesx'], marker='x') Out[11]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f68d7d45d60&gt;]</pre> In\u00a0[12]: Copied! <pre>plt.plot(result['quadvalsy'], np.sqrt(result['screen_sigma_33']))\nplt.plot(result['quadvalsy'], result['beamsizesy'], marker='x')\n</pre> plt.plot(result['quadvalsy'], np.sqrt(result['screen_sigma_33'])) plt.plot(result['quadvalsy'], result['beamsizesy'], marker='x') Out[12]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f68d7d38e20&gt;]</pre> In\u00a0[13]: Copied! <pre>import epics\nimport matplotlib.pyplot as plt\n\nfrom ipywidgets import interact\n\ndef f(quad_value):\n    epics.caput('QUAD:HTR:120:BCTRL', quad_value)\n    a = epics.caget('OTRS:HTR:330:Image:ArrayData').reshape(1040, 1392)\n    sigma_x = epics.caget('sim_screen_sigma_x')\n    sigma_y = epics.caget('sim_screen_sigma_y')  \n    print(sigma_x)\n    plt.imshow(a, vmax=128)\n    plt.title(f'sim sigma_x, y = {sigma_x*1e3:0.3f}    {sigma_y*1e3:0.3f} mm')\n    \n# interact(f, quad_value=(-4, 4, .1))    \nf(0)\n</pre> import epics import matplotlib.pyplot as plt  from ipywidgets import interact  def f(quad_value):     epics.caput('QUAD:HTR:120:BCTRL', quad_value)     a = epics.caget('OTRS:HTR:330:Image:ArrayData').reshape(1040, 1392)     sigma_x = epics.caget('sim_screen_sigma_x')     sigma_y = epics.caget('sim_screen_sigma_y')       print(sigma_x)     plt.imshow(a, vmax=128)     plt.title(f'sim sigma_x, y = {sigma_x*1e3:0.3f}    {sigma_y*1e3:0.3f} mm')      # interact(f, quad_value=(-4, 4, .1))     f(0) <pre>0.00037486171231124573\n</pre>"},{"location":"examples/simulated_online/#online-pyemittance","title":"Online PyEmittance\u00b6","text":"<p>The following will work either on a production system, or with a simulated EPICS server.</p> <p>For local development, start a simulated EPICS server using the <code>simulated_epics.ipynb</code> notebook, or run in a separate process:</p> <pre>from pyemittance.simulation_server import start_server\nstart_server()\n</pre>"},{"location":"examples/simulated_online/#examine-results","title":"Examine results\u00b6","text":""},{"location":"examples/simulated_online/#interactively-change-the-quad-and-acquire-the-screen-image","title":"Interactively change the quad and acquire the screen image\u00b6","text":""},{"location":"examples/simulated_quad_scan/","title":"Simulated Quad Scan","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pyemittance.emittance_calc import EmitCalc\nfrom pyemittance.load_json_configs import load_configs\n</pre> import numpy as np import matplotlib.pyplot as plt from pyemittance.emittance_calc import EmitCalc from pyemittance.load_json_configs import load_configs <p>Load this config and add a drift.</p> In\u00a0[3]: Copied! <pre>CONFIG = load_configs('LCLS2_OTR0H04')\nCONFIG['beamline_info']\n</pre> CONFIG = load_configs('LCLS2_OTR0H04') CONFIG['beamline_info'] Out[3]: <pre>{'name': 'LCLS2',\n 'species': 'electron',\n 'Lquad': 0.1244,\n 'energy': 80000000.0,\n 'Twiss0': [1e-06, 1e-06, 5.01, 5.01, 0.049, 0.049],\n 'rMatx': [1, 2.2, 0, 1],\n 'rMaty': [1, 2.2, 0, 1]}</pre> In\u00a0[4]: Copied! <pre>from pyemittance.simulation import BeamSim\n</pre> from pyemittance.simulation import BeamSim In\u00a0[5]: Copied! <pre>BUNCH_PARAMS0 = {\n    'total_charge': 50e-12,\n    'norm_emit_x': 1e-6,\n    'norm_emit_y': 2e-6,\n    'beta_x': 10,\n    'alpha_x': -1,\n    'beta_y': 11,\n    'alpha_y': -2,\n    'energy': 80e6,\n    'species':'electron'\n}\n</pre> BUNCH_PARAMS0 = {     'total_charge': 50e-12,     'norm_emit_x': 1e-6,     'norm_emit_y': 2e-6,     'beta_x': 10,     'alpha_x': -1,     'beta_y': 11,     'alpha_y': -2,     'energy': 80e6,     'species':'electron' } <p>Create the simulation</p> In\u00a0[6]: Copied! <pre>sim = BeamSim(bunch_params=BUNCH_PARAMS0, beamline_info=CONFIG['beamline_info'])\n</pre> sim = BeamSim(bunch_params=BUNCH_PARAMS0, beamline_info=CONFIG['beamline_info']) In\u00a0[7]: Copied! <pre>sim.screen_sigma('x'), sim.screen_sigma('y')\n</pre> sim.screen_sigma('x'), sim.screen_sigma('y') Out[7]: <pre>(0.000316975039076531, 0.0005391478973939177)</pre> <p>Set the scanning quadrupole (in machine units) and get the x and y beam sizes</p> In\u00a0[8]: Copied! <pre>sim.quad_value = 2\nsim.screen_beam_sizes()\n</pre> sim.quad_value = 2 sim.screen_beam_sizes() Out[8]: <pre>(0.00012627736478842047, 0.0011887442162668135)</pre> In\u00a0[9]: Copied! <pre>sim.plot_screen()\n</pre> sim.plot_screen() <p>Set the noise level. This just adds random numbers with a maximum value of this level.</p> In\u00a0[10]: Copied! <pre>sim.screen.noise=50\nsim.plot_screen()\n</pre> sim.screen.noise=50 sim.plot_screen() <p>Simple interaction</p> In\u00a0[11]: Copied! <pre>from ipywidgets import interact\n\ndef f(quad_value):\n    sim.quad_value = quad_value\n    sim.plot_screen()\n  \nf(1)\n\n# interact(f, quad_value=(-4, 4, .1), vmax=128)\n</pre> from ipywidgets import interact  def f(quad_value):     sim.quad_value = quad_value     sim.plot_screen()    f(1)  # interact(f, quad_value=(-4, 4, .1), vmax=128) In\u00a0[12]: Copied! <pre>quad_vals = np.linspace(-2,2, 20)\nmeas =  np.array([sim.beam_size_meas(v) for v in quad_vals])\nmeas_x = meas[:,0]\nmeas_y = meas[:,1]\n</pre> quad_vals = np.linspace(-2,2, 20) meas =  np.array([sim.beam_size_meas(v) for v in quad_vals]) meas_x = meas[:,0] meas_y = meas[:,1] In\u00a0[13]: Copied! <pre>plt.plot(quad_vals, meas_x*1e3, label='x')\nplt.plot(quad_vals, meas_y*1e3, label='y')\nplt.xlabel('quad value (machine units)')\nplt.ylabel('Beam size (mm)')\nplt.legend()\n</pre> plt.plot(quad_vals, meas_x*1e3, label='x') plt.plot(quad_vals, meas_y*1e3, label='y') plt.xlabel('quad value (machine units)') plt.ylabel('Beam size (mm)') plt.legend() Out[13]: <pre>&lt;matplotlib.legend.Legend at 0x7f1e743bb9a0&gt;</pre> In\u00a0[14]: Copied! <pre>ef = EmitCalc({'x': quad_vals,'y': quad_vals},\n              {'x': meas_x ,'y': meas_y},\n              {'x': meas_x*0.03 ,'y': meas_y*0.03},\n              config_dict=CONFIG,\n             )\n\nef.plot = True             \nresult = ef.get_emit()\n\nresult['norm_emit_x'], result['norm_emit_y'], result['beta_x'], result['beta_y'], result['alpha_x'], result['alpha_y']\n</pre> ef = EmitCalc({'x': quad_vals,'y': quad_vals},               {'x': meas_x ,'y': meas_y},               {'x': meas_x*0.03 ,'y': meas_y*0.03},               config_dict=CONFIG,              )  ef.plot = True              result = ef.get_emit()  result['norm_emit_x'], result['norm_emit_y'], result['beta_x'], result['beta_y'], result['alpha_x'], result['alpha_y'] Out[14]: <pre>(1.0000000000000002e-06,\n 1.9999999999999986e-06,\n 10.000000000000002,\n 11.00000000000001,\n -1.0,\n -2.000000000000002)</pre> In\u00a0[15]: Copied! <pre>print(ef.summary())\n</pre> print(ef.summary()) <pre>\"\n    Emittance Calculation Summary\n    \n    Emittance x: 1.000 +/- 0.022 mm mrad\n    Emittance y: 2.000 +/- 0.046 mm mrad\n    \n    Before scanning quad:\n                    x        y\n    norm_emit      1.00      2.00 (mm-mrad)                    \n    beta          10.00     11.00 (m)\n    alpha         -1.00     -2.00 (1)\n\n    \n    \n</pre> In\u00a0[16]: Copied! <pre>sim.quad_value = -2\nsim.plot_screen()\n</pre> sim.quad_value = -2 sim.plot_screen() <p>Get a raw image. Note that images are always (row, column), in image coordinates (0,0) is in the top left).</p> In\u00a0[17]: Copied! <pre>im = sim.screen_image()\nim.shape\n</pre> im = sim.screen_image() im.shape Out[17]: <pre>(1040, 1392)</pre> <p>These are the true beam sizes</p> In\u00a0[18]: Copied! <pre>sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes()\n</pre> sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes() In\u00a0[19]: Copied! <pre>from pyemittance.image import Image\n</pre> from pyemittance.image import Image In\u00a0[20]: Copied! <pre>raw_im = sim.screen_image()\nim = Image(raw_im,  sim.screen.nrow, sim.screen.ncol)\nim.reshape_im()\nplt.imshow(im.proc_image, vmax=128)\n</pre> raw_im = sim.screen_image() im = Image(raw_im,  sim.screen.nrow, sim.screen.ncol) im.reshape_im() plt.imshow(im.proc_image, vmax=128) Out[20]: <pre>&lt;matplotlib.image.AxesImage at 0x7f1e74101a30&gt;</pre> In\u00a0[21]: Copied! <pre>profx, profy = im.get_im_projection()\nplt.plot(profx, label=\"x-profile\")\nplt.plot(profy, label=\"y-profile\")\nplt.legend()\n</pre> profx, profy = im.get_im_projection() plt.plot(profx, label=\"x-profile\") plt.plot(profy, label=\"y-profile\") plt.legend() Out[21]: <pre>&lt;matplotlib.legend.Legend at 0x7f1e74082dc0&gt;</pre> In\u00a0[22]: Copied! <pre>fit_res = im.get_sizes(method = \"gaussian\", show_plots = True)\nxsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res\n</pre> fit_res = im.get_sizes(method = \"gaussian\", show_plots = True) xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res In\u00a0[23]: Copied! <pre>sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes()\nresolution = sim.screen.resolution\n\nmeas_sigma_x = xsize * resolution\nmeas_sigma_y = ysize * resolution\n</pre> sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes() resolution = sim.screen.resolution  meas_sigma_x = xsize * resolution meas_sigma_y = ysize * resolution <p>These agree fairly well:</p> In\u00a0[24]: Copied! <pre>meas_sigma_x/sim_sigma_x\n</pre> meas_sigma_x/sim_sigma_x Out[24]: <pre>1.0058960059913646</pre> In\u00a0[25]: Copied! <pre>meas_sigma_y/sim_sigma_y\n</pre> meas_sigma_y/sim_sigma_y Out[25]: <pre>0.9912648904067909</pre> In\u00a0[26]: Copied! <pre>im.proc_image\n</pre> im.proc_image Out[26]: <pre>array([[24,  0, 45, ..., 22, 32,  0],\n       [49, 42, 23, ..., 39,  4, 27],\n       [19, 15, 42, ..., 35, 17, 37],\n       ...,\n       [36, 21, 16, ..., 20, 31,  5],\n       [38,  1, 20, ..., 47,  2, 32],\n       [20,  4, 35, ..., 48,  8, 29]], dtype=int16)</pre>"},{"location":"examples/simulated_quad_scan/#simulated-quad-scan","title":"Simulated Quad Scan\u00b6","text":"<p>This will show a simple 'simulation' of a quadrupole scan of a beam to a screen.</p> <p>This assumes that the system consists of a thick quadrupole maget followed by an uncoupled linear transport map that the user provides. Here we will just use a 2.2 m long drift.</p>"},{"location":"examples/simulated_quad_scan/#simulation","title":"Simulation\u00b6","text":""},{"location":"examples/simulated_quad_scan/#measurements","title":"Measurements\u00b6","text":""},{"location":"examples/simulated_quad_scan/#make-the-data","title":"Make the data\u00b6","text":""},{"location":"examples/simulated_quad_scan/#emittance-calculation","title":"Emittance calculation\u00b6","text":""},{"location":"examples/simulated_quad_scan/#image-analysis","title":"Image Analysis\u00b6","text":"<p>PyEmittance has its own image analysis tools. Let's check these.</p>"},{"location":"examples/simulated_screen/","title":"Simulated Screen","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pyemittance.load_json_configs import load_configs\n</pre> import matplotlib.pyplot as plt import numpy as np  from pyemittance.load_json_configs import load_configs In\u00a0[3]: Copied! <pre>CONFIG = load_configs('LCLS2_OTR0H04')\nCONFIG.keys()\n</pre> CONFIG = load_configs('LCLS2_OTR0H04') CONFIG.keys() Out[3]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[4]: Copied! <pre>CONFIG['meas_pv_info']\n</pre> CONFIG['meas_pv_info'] Out[4]: <pre>{'diagnostic': {'pv': {'name': 'OTRS:HTR:330',\n   'image': 'OTRS:HTR:330:Image:ArrayData',\n   'nrow': 'OTRS:HTR:330:Image:ArraySize1_RBV',\n   'ncol': 'OTRS:HTR:330:Image:ArraySize0_RBV',\n   'resolution': 'OTRS:HTR:330:RESOLUTION',\n   'xsize': 'OTRS:HTR:330:XRMS',\n   'ysize': 'OTRS:HTR:330:YRMS'}},\n 'meas_device': {'settle_time': 1,\n  'bounds': [-2, 2],\n  'pv': {'name': 'QUAD:HTR:120',\n   'cntrl': 'QUAD:HTR:120:BCTRL',\n   'read': 'QUAD:HTR:120:BACT'}},\n 'beam_info': {'energy': ''}}</pre> In\u00a0[5]: Copied! <pre>from pyemittance.simulation import Screen\n</pre> from pyemittance.simulation import Screen In\u00a0[6]: Copied! <pre>S = Screen(noise=50)\nbg = S.background()\nplt.imshow(bg, vmax=128)\n</pre> S = Screen(noise=50) bg = S.background() plt.imshow(bg, vmax=128) Out[6]: <pre>&lt;matplotlib.image.AxesImage at 0x7f56e4adadf0&gt;</pre> In\u00a0[7]: Copied! <pre>s = S.spot(mean_x = 0, mean_y = -.001, total_charge=100e-12,\n           sigma_x = 0.00001,\n           sigma_y = 0.000530470,\n          n_particle=100_000\n          )\nplt.imshow(s+bg, vmax=128), s.std(), np.sum(s), s.max()\n</pre> s = S.spot(mean_x = 0, mean_y = -.001, total_charge=100e-12,            sigma_x = 0.00001,            sigma_y = 0.000530470,           n_particle=100_000           ) plt.imshow(s+bg, vmax=128), s.std(), np.sum(s), s.max() Out[7]: <pre>(&lt;matplotlib.image.AxesImage at 0x7f56e46e7ac0&gt;,\n 130.48147305149615,\n 9790336,\n 7199)</pre> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots()\nax.imshow(s + bg, extent=1e3*np.array([S.xmin, S.xmax, S.ymin, S.ymax]), vmax=128)\nax.set_xlabel('x (mm)')\nax.set_ylabel('y (mm)')\n</pre> fig, ax = plt.subplots() ax.imshow(s + bg, extent=1e3*np.array([S.xmin, S.xmax, S.ymin, S.ymax]), vmax=128) ax.set_xlabel('x (mm)') ax.set_ylabel('y (mm)') Out[8]: <pre>Text(0, 0.5, 'y (mm)')</pre>"},{"location":"examples/simulated_screen/#simulated-screen","title":"Simulated Screen\u00b6","text":""},{"location":"examples/simulated_screen/#blank-screen","title":"Blank Screen\u00b6","text":""},{"location":"examples/simulated_screen/#screen-with-spot","title":"Screen with spot\u00b6","text":""},{"location":"examples/old/lcls_optimizer/","title":"Lcls optimizer","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport datetime\n</pre> import numpy as np import datetime In\u00a0[\u00a0]: Copied! <pre>from bayes_opt import BayesianOptimization, UtilityFunction\nfrom scipy import optimize\n</pre> from bayes_opt import BayesianOptimization, UtilityFunction from scipy import optimize In\u00a0[\u00a0]: Copied! <pre>from pyemittance.pyemittance import eval_emit_machine\n</pre> from pyemittance.pyemittance import eval_emit_machine In\u00a0[\u00a0]: Copied! <pre>class Opt:\n    def __init__(self, init_scan=[-6, -4, -2, 0]):\n        self.varscan = init_scan\n        self.num_points_adapt = 7\n        self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))\n        self.plot = False\n        self.save_runs = False\n        self.online = False\n        self.uncertainty_lim = 0.25\n        self.timestamp = None\n        self.total_num_points = 0\n        self.seed = 12\n\n    def evaluate(self, varx, vary, varz):\n        # fixed initial varscan\n        quad_init = self.varscan\n        config = [varx, vary, varz]\n\n        out_dict, self.total_num_points = eval_emit_machine(config,\n                                                       quad_init=list(quad_init),\n                                                       online=self.online,\n                                                       name='LCLS',\n                                                       meas_type='OTRS',\n                                                       adapt_ranges=True,\n                                                       num_points=self.num_points_adapt,\n                                                       check_sym=True,\n                                                       infl_check=True,\n                                                       add_pnts=True,\n                                                       show_plots=self.plot,\n                                                       use_prev_meas=True,\n                                                       quad_tol=0.02,\n                                                       save_runs=self.save_runs,\n                                                       calc_bmag=True)\n\n        return out_dict\n\n    def evaluate_bo(self, varx, vary, varz):\n        out_dict = self.evaluate(varx, vary, varz)\n\n        emit = out_dict['nemit']\n        emit_err = out_dict['nemit_err']\n\n        if np.isnan(emit):\n            print(\"NaN emit\")\n            return np.nan, np.nan\n\n        if emit_err / emit &lt; self.uncertainty_lim:\n            # save total number of points added\n            timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n            f = open(f\"bo_points_meas_iter.txt\", \"a+\")\n            f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')\n            f.close()\n\n        return -emit, -emit_err\n\n    def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=120):\n        np.random.seed(self.seed)\n\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=None,\n            pbounds=bounds,\n            random_state=rnd_state,\n            verbose=2\n        )\n\n        # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)\n        utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)\n\n        target_list = []\n\n        # init random points\n        x = []\n        emit_list = []\n        emit_err_list = []\n\n        emit_res = (np.nan, np.nan)\n        while len(emit_list) &lt; init_pnts:\n            x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n                   np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n                   np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]\n            emit_res = self.evaluate(x_i[0], x_i[1], x_i[2])\n\n            if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):# and abs(emit_res[0]) &gt; 58e-8:\n                # take large init emittances\n                x.append(x_i)\n                emit_list.append(emit_res[0])\n                emit_err_list.append(emit_res[1])\n\n        print(\"Init configs: \", x)\n        print(\"Init emit: \", emit_list)\n        # get init points\n        for i in range(len(x)):\n            # target, error = np.nan, np.nan\n            # hile np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:\n            next_point = {'varx': x[i][0],\n                          'vary': x[i][1],\n                          'varz': x[i][2]\n                          }\n            #                 # evaluate next point\n            target = emit_list[i]\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f} \"\n                f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            target_list.append(target)\n\n        # BO iters\n        for i in range(n_iter):\n            target, error = np.nan, np.nan\n            while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:\n                next_point = optimizer.suggest(utility)\n                target, error = self.evaluate(**next_point)\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f}\"\n                f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            emit_list.append(target)\n            emit_err_list.append(error)\n            target_list.append(target)\n\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_list,\n                allow_pickle=True)\n        np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_err_list,\n                allow_pickle=True)\n        np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', optimizer.res,\n                allow_pickle=True)\n\n        return optimizer\n\n    def eval_simplex(self, x):\n        out_dict = self.evaluate(x[0], x[1], x[2])\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        emit = out_dict['nemit']\n        err = out_dict['nemit_err']\n        \n        if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):\n            print(\"NaN or high uncertainty emittance, returning 100.\")\n            f = open(f\"simplex_run.txt\", \"a+\")\n            f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')\n            f.close()\n            return 100\n\n        f = open(f\"simplex_run.txt\", \"a+\")\n        f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')\n        f.close()\n\n        return emit\n\n    def run_simplex_opt(self, max_iter):\n\n        np.random.seed(self.seed)\n\n        initial_guess = np.array(\n            [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ])\n\n        # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])\n        # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])\n        # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])\n\n        # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])\n\n        min = optimize.minimize(self.eval_simplex, initial_guess,\n                                method='Nelder-Mead', options={'maxiter': max_iter,\n                                                               'return_all': True,\n                                                               'adaptive': True,\n                                                               'fatol': 0.1 * 0.75,\n                                                               'xatol': 0.00001\n                                                               },\n                                )\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n        np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)\n\n        f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")\n        f.write(min)\n        f.close()\n\n        return min\n\n    def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=self.evaluate,\n            pbounds=bounds,\n            random_state=rnd_state,\n        )\n\n        #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)\n        optimizer.maximize(init_points=init_pnts,\n                           n_iter=n_iter,\n                           kappa=0.01\n                           # kappa_decay = 0.8,\n                           # kappa_decay_delay = 25\n                           )\n\n        return optimizer\n\n    def run_simplex_opt_norm(self, max_iter):\n        np.random.seed(self.seed)\n\n        # below code based on Badger implementation of simplex for the ACR\n\n        # vars init values\n        x0 = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ]\n        # lower bounds\n        lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]\n        # upper bounds\n        ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]\n        # normalization coeff\n        gain = 4\n        # tolerance\n        xtol = 1e-9\n\n        # Convert (possible) list to array\n        x0 = np.array(x0)\n        lb = np.array(lb)\n        ub = np.array(ub)\n\n        x0_raw = lb + x0 * (ub - lb)\n        mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))\n        sigma = np.sqrt(np.abs(mu))\n\n        x0_n = (x0_raw - mu) / sigma  # normalized x0\n\n        def _evaluate(x_n):\n            x_n = np.array(x_n)\n            x_raw = mu + sigma * x_n  # denormalization from Ocelot\n            x = (x_raw - lb) / (ub - lb)  # normalization for Badger\n            y = self.eval_simplex(x)\n\n            return y\n\n        res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,\n                            full_output=True)\n\n        print(res)\n\n        return res\n</pre> class Opt:     def __init__(self, init_scan=[-6, -4, -2, 0]):         self.varscan = init_scan         self.num_points_adapt = 7         self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))         self.plot = False         self.save_runs = False         self.online = False         self.uncertainty_lim = 0.25         self.timestamp = None         self.total_num_points = 0         self.seed = 12      def evaluate(self, varx, vary, varz):         # fixed initial varscan         quad_init = self.varscan         config = [varx, vary, varz]          out_dict, self.total_num_points = eval_emit_machine(config,                                                        quad_init=list(quad_init),                                                        online=self.online,                                                        name='LCLS',                                                        meas_type='OTRS',                                                        adapt_ranges=True,                                                        num_points=self.num_points_adapt,                                                        check_sym=True,                                                        infl_check=True,                                                        add_pnts=True,                                                        show_plots=self.plot,                                                        use_prev_meas=True,                                                        quad_tol=0.02,                                                        save_runs=self.save_runs,                                                        calc_bmag=True)          return out_dict      def evaluate_bo(self, varx, vary, varz):         out_dict = self.evaluate(varx, vary, varz)          emit = out_dict['nemit']         emit_err = out_dict['nemit_err']          if np.isnan(emit):             print(\"NaN emit\")             return np.nan, np.nan          if emit_err / emit &lt; self.uncertainty_lim:             # save total number of points added             timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")             f = open(f\"bo_points_meas_iter.txt\", \"a+\")             f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')             f.close()          return -emit, -emit_err      def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=120):         np.random.seed(self.seed)          # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=None,             pbounds=bounds,             random_state=rnd_state,             verbose=2         )          # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)         utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)          target_list = []          # init random points         x = []         emit_list = []         emit_err_list = []          emit_res = (np.nan, np.nan)         while len(emit_list) &lt; init_pnts:             x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),                    np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),                    np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]             emit_res = self.evaluate(x_i[0], x_i[1], x_i[2])              if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):# and abs(emit_res[0]) &gt; 58e-8:                 # take large init emittances                 x.append(x_i)                 emit_list.append(emit_res[0])                 emit_err_list.append(emit_res[1])          print(\"Init configs: \", x)         print(\"Init emit: \", emit_list)         # get init points         for i in range(len(x)):             # target, error = np.nan, np.nan             # hile np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:             next_point = {'varx': x[i][0],                           'vary': x[i][1],                           'varz': x[i][2]                           }             #                 # evaluate next point             target = emit_list[i]              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f} \"                 f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             target_list.append(target)          # BO iters         for i in range(n_iter):             target, error = np.nan, np.nan             while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:                 next_point = optimizer.suggest(utility)                 target, error = self.evaluate(**next_point)              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f}\"                 f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             emit_list.append(target)             emit_err_list.append(error)             target_list.append(target)          timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_list,                 allow_pickle=True)         np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_err_list,                 allow_pickle=True)         np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', optimizer.res,                 allow_pickle=True)          return optimizer      def eval_simplex(self, x):         out_dict = self.evaluate(x[0], x[1], x[2])         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          emit = out_dict['nemit']         err = out_dict['nemit_err']                  if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):             print(\"NaN or high uncertainty emittance, returning 100.\")             f = open(f\"simplex_run.txt\", \"a+\")             f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')             f.close()             return 100          f = open(f\"simplex_run.txt\", \"a+\")         f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')         f.close()          return emit      def run_simplex_opt(self, max_iter):          np.random.seed(self.seed)          initial_guess = np.array(             [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ])          # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])         # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])         # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])          # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])          min = optimize.minimize(self.eval_simplex, initial_guess,                                 method='Nelder-Mead', options={'maxiter': max_iter,                                                                'return_all': True,                                                                'adaptive': True,                                                                'fatol': 0.1 * 0.75,                                                                'xatol': 0.00001                                                                },                                 )         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")         np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)          f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")         f.write(min)         f.close()          return min      def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):         # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=self.evaluate,             pbounds=bounds,             random_state=rnd_state,         )          #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)         optimizer.maximize(init_points=init_pnts,                            n_iter=n_iter,                            kappa=0.01                            # kappa_decay = 0.8,                            # kappa_decay_delay = 25                            )          return optimizer      def run_simplex_opt_norm(self, max_iter):         np.random.seed(self.seed)          # below code based on Badger implementation of simplex for the ACR          # vars init values         x0 = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ]         # lower bounds         lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]         # upper bounds         ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]         # normalization coeff         gain = 4         # tolerance         xtol = 1e-9          # Convert (possible) list to array         x0 = np.array(x0)         lb = np.array(lb)         ub = np.array(ub)          x0_raw = lb + x0 * (ub - lb)         mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))         sigma = np.sqrt(np.abs(mu))          x0_n = (x0_raw - mu) / sigma  # normalized x0          def _evaluate(x_n):             x_n = np.array(x_n)             x_raw = mu + sigma * x_n  # denormalization from Ocelot             x = (x_raw - lb) / (ub - lb)  # normalization for Badger             y = self.eval_simplex(x)              return y          res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,                             full_output=True)          print(res)          return res"},{"location":"examples/old/sim_optimizer/","title":"Sim optimizer","text":"In\u00a0[\u00a0]: Copied! <pre>from argparse import Namespace\nimport datetime\nimport numpy as np\nfrom bayes_opt import BayesianOptimization, UtilityFunction\nfrom scipy import optimize\n</pre> from argparse import Namespace import datetime import numpy as np from bayes_opt import BayesianOptimization, UtilityFunction from scipy import optimize In\u00a0[\u00a0]: Copied! <pre>from pyemittance.emit_eval_example import eval_emit_surrogate\nfrom lcls_functions import Lcls\n</pre> from pyemittance.emit_eval_example import eval_emit_surrogate from lcls_functions import Lcls In\u00a0[\u00a0]: Copied! <pre>class Opt:\n    def __init__(self, init_scan=np.linspace(-6, 0, 4), bsfn=None):\n        self.varscan = init_scan\n        self.num_points_adapt = 7\n        self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))\n        self.plot = False\n        self.bsfn = None\n        self.uncertainty_lim = 0.25\n        self.timestamp = None\n        self.noise = False\n        if bsfn is None:\n            bsfn = self.get_default_bsfn()\n        self.bsfn = bsfn\n        self.total_num_points = 0\n        self.seed = 12\n\n    def get_default_bsfn(self):\n        lcls_params = Namespace(\n            config_bounds=[(self.pbounds[0][0], self.pbounds[0][1]),\n                           (self.pbounds[1][0], self.pbounds[1][1]),\n                           (self.pbounds[2][0], self.pbounds[2][1])],\n            quad_bounds=(-6.0, 0.0),\n            beamsizes_bounds=[(0.0, 5e-4), (0.0, 5e-4)],\n        )\n        lcls = Lcls(params=lcls_params)\n        bsfn = lcls.beamsizes_list_fn\n        return bsfn\n\n    def get_beamsizes_model(self, config, val):\n        beamsizes_list = self.bsfn(config, [val], verbose=False)[0]\n        xrms = beamsizes_list[0]\n        yrms = beamsizes_list[1]\n        xrms_err = xrms * 0.03\n        yrms_err = yrms * 0.03\n        return xrms, yrms, xrms_err, yrms_err\n\n    def evaluate(self, varx, vary, varz):\n        # fixed varscan\n        quad_init = self.varscan\n        config = [varx, vary, varz]\n\n        out_dict, self.total_num_points = eval_emit_surrogate(\n            self.get_beamsizes_model,\n            config,\n            quad_init=list(quad_init),\n            adapt_ranges=True,\n            num_points=self.num_points_adapt,\n            check_sym=True,\n            infl_check=True,\n            add_pnts=True,\n            show_plots=self.plot,\n            add_noise=self.noise,\n        )\n\n        return out_dict\n\n    def evaluate_bo(self, varx, vary, varz):\n        out_dict = self.evaluate(varx, vary, varz)\n\n        emit = out_dict['nemit']\n        emit_err = out_dict['nemit_err']\n\n        if np.isnan(emit):\n            print(\"NaN emit\")\n            return np.nan, np.nan\n\n        if emit_err / emit &lt; self.uncertainty_lim:\n            # save total number of points added\n            timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n            f = open(f\"bo_noisy_seed_{self.seed}.txt\", \"a+\")\n            f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')\n            f.close()\n\n        return -emit, -emit_err\n\n    def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=200):\n        np.random.seed(self.seed)\n\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=None,\n            pbounds=bounds,\n            random_state=rnd_state,\n            verbose=2\n        )\n\n        # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)\n        utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)\n\n        target_list = []\n\n        # init random points\n        x = []\n        emit_list = []\n        emit_err_list = []\n\n        emit_res = (np.nan, np.nan)\n        while len(emit_list) &lt; init_pnts:\n            x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n                   np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n                   np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]\n            emit_res = self.evaluate_bo(x_i[0], x_i[1], x_i[2])\n\n            if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):  # and abs(emit_res[0]) &gt; 1.0:\n                x.append(x_i)\n                emit_list.append(emit_res[0])\n                emit_err_list.append(emit_res[1])\n\n        # get init points\n        for i in range(len(x)):\n            # target, error = np.nan, np.nan\n            #             while np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:\n            next_point = {'varx': x[i][0],\n                          'vary': x[i][1],\n                          'varz': x[i][2]\n                          }\n            #                 # evaluate next point\n            target = emit_list[i]\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f}\"\n                f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            target_list.append(target)\n\n        # BO iters\n        for i in range(n_iter):\n            target, error = np.nan, np.nan\n            while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:\n                next_point = optimizer.suggest(utility)\n                target, error = self.evaluate_bo(**next_point)\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f} \"\n                f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            emit_list.append(target)\n            emit_err_list.append(error)\n            target_list.append(target)\n\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                emit_list, allow_pickle=True)\n        np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                emit_err_list, allow_pickle=True)\n        np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                optimizer.res, allow_pickle=True)\n\n        return optimizer\n\n    def eval_simplex(self, x):\n        out_dict = self.evaluate(x[0], x[1], x[2])\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        emit = out_dict['nemit']\n        err = out_dict['nemit_err']\n\n        if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):\n            print(\"NaN emit\")\n            f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")\n            f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')\n            f.close()\n            return 100\n\n        f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")\n        f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')\n        f.close()\n\n        return emit\n\n    def run_simplex_opt(self, max_iter):\n\n        np.random.seed(self.seed)\n\n        initial_guess = np.array(\n            [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ])\n\n        # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])\n        # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])\n        # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])\n\n        # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])\n\n        min = optimize.minimize(self.eval_simplex, initial_guess,\n                                method='Nelder-Mead', options={'maxiter': max_iter,\n                                                               'return_all': True,\n                                                               'adaptive': True,\n                                                               'fatol': 0.1 * 0.75,\n                                                               'xatol': 0.00001\n                                                               },\n                                )\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n        np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)\n\n        f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")\n        f.write(min)\n        f.close()\n\n        return min\n\n    def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=self.evaluate,\n            pbounds=bounds,\n            random_state=rnd_state,\n        )\n\n        #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)\n        optimizer.maximize(init_points=init_pnts,\n                           n_iter=n_iter,\n                           kappa=0.01\n                           # kappa_decay = 0.8,\n                           # kappa_decay_delay = 25\n                           )\n\n        return optimizer\n\n    def run_simplex_opt_norm(self, max_iter):\n        np.random.seed(self.seed)\n\n        # below code based on Badger implementation of simplex for the ACR\n\n        # vars init values\n        # x0 = [0.46875, (self.pbounds[1][0] + self.pbounds[1][1]) / 2, (self.pbounds[2][0] + self.pbounds[2][1]) / 2]\n        # ref point from sim\n        x0 = [0.4779693455075814, -0.001499227120199691, -0.0006872989433749197]\n        # lower bounds\n        lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]\n        # upper bounds\n        ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]\n        # normalization coeff\n        gain = 1.8\n        # tolerance\n        xtol = 1e-9\n\n        # Convert (possible) list to array\n        x0 = np.array(x0)\n        lb = np.array(lb)\n        ub = np.array(ub)\n\n        x0_raw = lb + x0 * (ub - lb)\n        mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))\n        sigma = np.sqrt(np.abs(mu))\n\n        x0_n = (x0_raw - mu) / sigma  # normalized x0\n\n        def _evaluate(x_n):\n            x_n = np.array(x_n)\n            x_raw = mu + sigma * x_n  # denormalization from Ocelot\n            x = (x_raw - lb) / (ub - lb)  # normalization for Badger\n            y = self.eval_simplex(x)\n\n            return y\n\n        res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,\n                            full_output=True)\n\n        print(res)\n\n        return res\n</pre> class Opt:     def __init__(self, init_scan=np.linspace(-6, 0, 4), bsfn=None):         self.varscan = init_scan         self.num_points_adapt = 7         self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))         self.plot = False         self.bsfn = None         self.uncertainty_lim = 0.25         self.timestamp = None         self.noise = False         if bsfn is None:             bsfn = self.get_default_bsfn()         self.bsfn = bsfn         self.total_num_points = 0         self.seed = 12      def get_default_bsfn(self):         lcls_params = Namespace(             config_bounds=[(self.pbounds[0][0], self.pbounds[0][1]),                            (self.pbounds[1][0], self.pbounds[1][1]),                            (self.pbounds[2][0], self.pbounds[2][1])],             quad_bounds=(-6.0, 0.0),             beamsizes_bounds=[(0.0, 5e-4), (0.0, 5e-4)],         )         lcls = Lcls(params=lcls_params)         bsfn = lcls.beamsizes_list_fn         return bsfn      def get_beamsizes_model(self, config, val):         beamsizes_list = self.bsfn(config, [val], verbose=False)[0]         xrms = beamsizes_list[0]         yrms = beamsizes_list[1]         xrms_err = xrms * 0.03         yrms_err = yrms * 0.03         return xrms, yrms, xrms_err, yrms_err      def evaluate(self, varx, vary, varz):         # fixed varscan         quad_init = self.varscan         config = [varx, vary, varz]          out_dict, self.total_num_points = eval_emit_surrogate(             self.get_beamsizes_model,             config,             quad_init=list(quad_init),             adapt_ranges=True,             num_points=self.num_points_adapt,             check_sym=True,             infl_check=True,             add_pnts=True,             show_plots=self.plot,             add_noise=self.noise,         )          return out_dict      def evaluate_bo(self, varx, vary, varz):         out_dict = self.evaluate(varx, vary, varz)          emit = out_dict['nemit']         emit_err = out_dict['nemit_err']          if np.isnan(emit):             print(\"NaN emit\")             return np.nan, np.nan          if emit_err / emit &lt; self.uncertainty_lim:             # save total number of points added             timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")             f = open(f\"bo_noisy_seed_{self.seed}.txt\", \"a+\")             f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')             f.close()          return -emit, -emit_err      def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=200):         np.random.seed(self.seed)          # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=None,             pbounds=bounds,             random_state=rnd_state,             verbose=2         )          # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)         utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)          target_list = []          # init random points         x = []         emit_list = []         emit_err_list = []          emit_res = (np.nan, np.nan)         while len(emit_list) &lt; init_pnts:             x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),                    np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),                    np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]             emit_res = self.evaluate_bo(x_i[0], x_i[1], x_i[2])              if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):  # and abs(emit_res[0]) &gt; 1.0:                 x.append(x_i)                 emit_list.append(emit_res[0])                 emit_err_list.append(emit_res[1])          # get init points         for i in range(len(x)):             # target, error = np.nan, np.nan             #             while np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:             next_point = {'varx': x[i][0],                           'vary': x[i][1],                           'varz': x[i][2]                           }             #                 # evaluate next point             target = emit_list[i]              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f}\"                 f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             target_list.append(target)          # BO iters         for i in range(n_iter):             target, error = np.nan, np.nan             while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:                 next_point = optimizer.suggest(utility)                 target, error = self.evaluate_bo(**next_point)              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f} \"                 f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             emit_list.append(target)             emit_err_list.append(error)             target_list.append(target)          timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 emit_list, allow_pickle=True)         np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 emit_err_list, allow_pickle=True)         np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 optimizer.res, allow_pickle=True)          return optimizer      def eval_simplex(self, x):         out_dict = self.evaluate(x[0], x[1], x[2])         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          emit = out_dict['nemit']         err = out_dict['nemit_err']          if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):             print(\"NaN emit\")             f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")             f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')             f.close()             return 100          f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")         f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')         f.close()          return emit      def run_simplex_opt(self, max_iter):          np.random.seed(self.seed)          initial_guess = np.array(             [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ])          # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])         # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])         # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])          # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])          min = optimize.minimize(self.eval_simplex, initial_guess,                                 method='Nelder-Mead', options={'maxiter': max_iter,                                                                'return_all': True,                                                                'adaptive': True,                                                                'fatol': 0.1 * 0.75,                                                                'xatol': 0.00001                                                                },                                 )         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")         np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)          f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")         f.write(min)         f.close()          return min      def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):         # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=self.evaluate,             pbounds=bounds,             random_state=rnd_state,         )          #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)         optimizer.maximize(init_points=init_pnts,                            n_iter=n_iter,                            kappa=0.01                            # kappa_decay = 0.8,                            # kappa_decay_delay = 25                            )          return optimizer      def run_simplex_opt_norm(self, max_iter):         np.random.seed(self.seed)          # below code based on Badger implementation of simplex for the ACR          # vars init values         # x0 = [0.46875, (self.pbounds[1][0] + self.pbounds[1][1]) / 2, (self.pbounds[2][0] + self.pbounds[2][1]) / 2]         # ref point from sim         x0 = [0.4779693455075814, -0.001499227120199691, -0.0006872989433749197]         # lower bounds         lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]         # upper bounds         ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]         # normalization coeff         gain = 1.8         # tolerance         xtol = 1e-9          # Convert (possible) list to array         x0 = np.array(x0)         lb = np.array(lb)         ub = np.array(ub)          x0_raw = lb + x0 * (ub - lb)         mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))         sigma = np.sqrt(np.abs(mu))          x0_n = (x0_raw - mu) / sigma  # normalized x0          def _evaluate(x_n):             x_n = np.array(x_n)             x_raw = mu + sigma * x_n  # denormalization from Ocelot             x = (x_raw - lb) / (ub - lb)  # normalization for Badger             y = self.eval_simplex(x)              return y          res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,                             full_output=True)          print(res)          return res"},{"location":"examples/old/tutorial/","title":"PyEmittance Tutorial","text":"In\u00a0[1]: Copied! <pre>from pyemittance import PyEmittance\nimport numpy as np\n</pre> from pyemittance import PyEmittance import numpy as np In\u00a0[2]: Copied! <pre>meas = PyEmittance()\n</pre> meas = PyEmittance() In\u00a0[3]: Copied! <pre>meas.config_name\n</pre> meas.config_name Out[3]: <pre>'LCLS_OTR2'</pre> In\u00a0[4]: Copied! <pre>meas.num_points = 5\n</pre> meas.num_points = 5 In\u00a0[5]: Copied! <pre># see all configs with command below\nmeas.config_dict.keys()\n</pre> # see all configs with command below meas.config_dict.keys() Out[5]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[6]: Copied! <pre>meas.config_dict['img_proc']\n</pre> meas.config_dict['img_proc'] Out[6]: <pre>{'subtract_bg': False,\n 'use_roi': False,\n 'avg_ims': True,\n 'n_to_acquire': 5,\n 'background_im': None,\n 'amp_threshold': 1500,\n 'min_sigma': 1.0,\n 'max_sigma': 60,\n 'max_samples': 3,\n 'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}}</pre> In\u00a0[7]: Copied! <pre>meas.quad_init\n</pre> meas.quad_init Out[7]: <pre>[-6, -4, -2, 0]</pre> In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nres = meas.measure_emittance()\n</pre> import matplotlib.pyplot as plt res = meas.measure_emittance() <pre>No settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nEmittance can't be computed. Returning error\n</pre> In\u00a0[9]: Copied! <pre>meas.config_dict['beamline_info']\n</pre> meas.config_dict['beamline_info'] Out[9]: <pre>{'name': 'LCLS',\n 'Lquad': 0.108,\n 'energy': 135000000.0,\n 'Twiss0': [1e-06,\n  1e-06,\n  1.113081026,\n  1.113021659,\n  -0.0689403587,\n  -0.07029489754],\n 'rMatx': [1, 2.26, 0, 1],\n 'rMaty': [1, 2.26, 0, 1]}</pre> <p>The output is a large dict:</p> In\u00a0[10]: Copied! <pre>res\n</pre> res Out[10]: <pre>{'quadvalsx': array([0., 0., 0., 0., 0., 0., 0., 0., 0.]),\n 'beamsizesx': array([6.30702269e-05, 6.30702269e-05, 6.30702269e-05, 6.30702269e-05,\n        6.30702269e-05, 6.30702269e-05, 6.30702269e-05, 6.30702269e-05,\n        6.30702269e-05]),\n 'beamsizeserrx': array([9.46053404e-07, 9.46053404e-07, 9.46053404e-07, 9.46053404e-07,\n        9.46053404e-07, 9.46053404e-07, 9.46053404e-07, 9.46053404e-07,\n        9.46053404e-07]),\n 'error_x': True,\n 'quadvalsy': array([-6. , -4.5, -3. , -1.5,  0. ,  0. ,  0. ]),\n 'beamsizesy': array([0.00053606, 0.00050883, 0.0005119 , 0.00035266, 0.00052127,\n        0.00052127, 0.00052127]),\n 'beamsizeserry': array([8.04083842e-06, 7.63244809e-06, 7.67855187e-06, 5.28993508e-06,\n        7.81907541e-06, 7.81907541e-06, 7.81907541e-06]),\n 'error_y': False,\n 'emit_y': 4.117030969316072e-08,\n 'norm_emit_y': 1.0876640729264264e-05,\n 'beta_y': 1.4372617697654138,\n 'alpha_y': -0.11903992810633181,\n 'emit_y_err': 7.079597148831201e-10,\n 'norm_emit_y_err': 1.8703341138226206e-07,\n 'beta_y_rel_err': 0.017195880238926764,\n 'alpha_y_rel_err': -2.843170842195371e-16,\n 'sigma_33': 5.917251217138234e-08,\n 'sigma_34': 4.900910705989267e-09,\n 'sigma_44': 2.9050876207520756e-08,\n 'screen_sigma_33': array([3.36983386e-07, 2.14130097e-07, 1.56282661e-07, 1.65849037e-07,\n        2.45283806e-07, 2.45283806e-07, 2.45283806e-07]),\n 'screen_sigma_34': array([1.91039796e-07, 1.18882017e-07, 7.45714281e-08, 5.91533334e-08,\n        7.36933856e-08, 7.36933856e-08, 7.36933856e-08]),\n 'screen_sigma_44': array([1.13332585e-07, 7.39173452e-08, 4.64280059e-08, 3.13183083e-08,\n        2.90508762e-08, 2.90508762e-08, 2.90508762e-08])}</pre> In\u00a0[11]: Copied! <pre>meas.online = True\n</pre> meas.online = True In\u00a0[12]: Copied! <pre>try:\n    res = meas.measure_emittance()\nexcept:\n    pass # epics can't connect on my local pc\n</pre> try:     res = meas.measure_emittance() except:     pass # epics can't connect on my local pc <pre>No settle_time found in in meas_device, setting to zero\n</pre> <pre>cannot connect to OTRS:IN20:541:RESOLUTION\n</pre> In\u00a0[13]: Copied! <pre>def get_bs_model(*args):\n    return abs(np.random.normal(1e-6, 5e-5)), abs(np.random.normal(1e-6, 5e-6)), 0, 0\n\nget_bs_model()\n</pre> def get_bs_model(*args):     return abs(np.random.normal(1e-6, 5e-5)), abs(np.random.normal(1e-6, 5e-6)), 0, 0  get_bs_model() Out[13]: <pre>(3.09089271261053e-05, 1.4706189223551029e-06, 0, 0)</pre> In\u00a0[14]: Copied! <pre>meas.use_model=True\nmeas.online = False # meaningless when running with a model\nmeas.get_bs_model = get_bs_model\n</pre> meas.use_model=True meas.online = False # meaningless when running with a model meas.get_bs_model = get_bs_model In\u00a0[15]: Copied! <pre>res = meas.measure_emittance()\n</pre> res = meas.measure_emittance() <pre>No settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nNo settle_time found in in meas_device, setting to zero\nEmittance can't be computed. Returning error\n</pre> In\u00a0[16]: Copied! <pre>res\n</pre> res Out[16]: <pre>{'quadvalsx': array([-6., -6., -6., -6., -6., -6., -6., -6., -6.]),\n 'beamsizesx': array([0.00022303, 0.00022303, 0.00022303, 0.00022303, 0.00022303,\n        0.00022303, 0.00022303, 0.00022303, 0.00022303]),\n 'beamsizeserrx': array([3.3454482e-06, 3.3454482e-06, 3.3454482e-06, 3.3454482e-06,\n        3.3454482e-06, 3.3454482e-06, 3.3454482e-06, 3.3454482e-06,\n        3.3454482e-06]),\n 'error_x': True,\n 'quadvalsy': array([-2.94771357, -1.96514238, -1.47385678, -0.98257119, -0.49128559]),\n 'beamsizesy': array([0.00042516, 0.00024014, 0.00032786, 0.00034117, 0.00020903]),\n 'beamsizeserry': array([6.37744251e-06, 3.60215292e-06, 4.91793777e-06, 5.11754753e-06,\n        3.13540561e-06]),\n 'error_y': False,\n 'emit_y': 1.9617471619428e-08,\n 'norm_emit_y': 5.182671503112402e-06,\n 'beta_y': 2.222563318025903,\n 'alpha_y': 0.8324981174439505,\n 'emit_y_err': 2.273739541049526e-09,\n 'norm_emit_y_err': 6.006913303357105e-07,\n 'beta_y_rel_err': 0.11590380173139872,\n 'alpha_y_rel_err': 7.227102111144115e-17,\n 'sigma_33': 4.360107281375487e-08,\n 'sigma_34': -1.6331508192183936e-08,\n 'sigma_44': 1.494374588794257e-08,\n 'screen_sigma_33': array([1.26103213e-07, 8.01767804e-08, 6.48371224e-08, 5.46616425e-08,\n        4.97121811e-08]),\n 'screen_sigma_34': array([7.90027290e-08, 5.02030442e-08, 3.90695741e-08, 3.01491977e-08,\n        2.34687614e-08]),\n 'screen_sigma_44': array([5.25464514e-08, 3.62348155e-08, 2.94781252e-08, 2.36696018e-08,\n        1.88208993e-08])}</pre>"},{"location":"examples/old/tutorial/#pyemittance-tutorial","title":"PyEmittance Tutorial\u00b6","text":""},{"location":"examples/old/tutorial/#three-options-for-setting-configurations-for-measurements","title":"Three options for setting configurations for measurements:\u00b6","text":"<ol> <li>Make directory under <code>configs/</code> with Machine_Device_Name with all needed jsons (see <code>configs/LCLS2_OTR3</code>), and pass dir name to <code>meas.config_name</code></li> <li>Change params and configs through class attributes</li> <li>pass the dictionary to pyemittance (same keys and subkeys as <code>meas.config_dict</code> below)</li> </ol>"},{"location":"examples/old/tutorial/#example-running-offline-with-random-beam-size-numbers","title":"Example running offline with random beam size numbers\u00b6","text":""},{"location":"examples/old/tutorial/#example-running-online-do-not-run-on-machine","title":"Example running online (do not run on machine!)\u00b6","text":""},{"location":"examples/old/tutorial/#example-running-with-some-random-beamsize-model","title":"Example running with some random beamsize model\u00b6","text":""},{"location":"examples/old/tutorial/#can-be-any-simulation-just-need-to-pass-pyemittance-the-beamsize-fn","title":"(can be any simulation, just need to pass pyemittance the beamsize fn)\u00b6","text":""}]}