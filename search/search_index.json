{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>PyEmittance is a tool for the adaptive measurement of beam emittance (e.g. of an electron beam at OTR/YAG beam profile monitors) using a single quadrupole scan developed at SLAC National Accelerator Laboratory. The Twiss parameters and the 'Bmag' match parameter can also be obtained. It can be used in different beamlines/machines by defining machine-specific configuration files. </p> <p>This tool was designed for robustness during online machine learning optimizations where each measurement needs to be reliable. It is still a work in progress, with version 1.0 to be released soon.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-setuptools","title":"Using setuptools","text":"<pre><code>python setup.py install\n</code></pre>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code># From PyPI distribution\npip install pyemittance\n\n# or from the source folder\npip install .\n</code></pre>"},{"location":"examples/config_setup_example/","title":"Config files setup for EPICS systems","text":"<p>NOTE! make sure your files are the only json files in the directory pyemittance/configs/ (delete or remove others).</p> <p>Required files:</p> <ol> <li>beamline_info.json : measurements</li> <li>img_proc.json :  required only if doing OTR image analysis (sigma units in meters, bg_im needs to be the path to the .npy file of the background image array)</li> <li>meas_pv_info.json : required PVs for measurement devices (OTR, wire, quad)</li> </ol> <p>Optionally: 4. savepaths.json : required for defining directories for saving</p> <p>The most important file for the emittance computation is</p> In\u00a0[1]: Copied! <pre>import json\njson.load(open(\"../../pyemittance/configs/LCLS_OTR3/beamline_info.json\"))\n</pre> import json json.load(open(\"../../pyemittance/configs/LCLS_OTR3/beamline_info.json\")) Out[1]: <pre>{'name': 'LCLS',\n 'Lquad': 0.108,\n 'energy': 135000000.0,\n 'Twiss0': [1e-06, 1e-06, 4.68280051, 4.68872767, -1.79636538, -1.79814306],\n 'rMatx': [1, 4.17, 0, 1],\n 'rMaty': [1, 4.17, 0, 1]}</pre> <p>The important params are:</p> <ul> <li>beam_info['Lquad'] : scanning quad effective length [m]</li> <li>beam_info['energy'] : beam energy [eV]</li> <li>beam_info['Twiss0'] : design Twiss at measurement location (e_x, e_y, beta_x, beta_y, alpha_x, alpha_y)</li> <li>beam_info['rMatx'], beam_info['rMaty'] : 2x2 transfer matrices for x, y from scanning to quad to OTR/screen, critical when there is more than a drift (quads, etc) in between, and this r-matrix takes into account those contributions (need to get from external model).</li> </ul> In\u00a0[2]: Copied! <pre>from pyemittance.load_json_configs import load_configs\n</pre> from pyemittance.load_json_configs import load_configs In\u00a0[3]: Copied! <pre>load_configs(\"../../pyemittance/configs/LCLS_OTR3/\")\n</pre> load_configs(\"../../pyemittance/configs/LCLS_OTR3/\") Out[3]: <pre>{'beamline_info': {'name': 'LCLS',\n  'Lquad': 0.108,\n  'energy': 135000000.0,\n  'Twiss0': [1e-06, 1e-06, 4.68280051, 4.68872767, -1.79636538, -1.79814306],\n  'rMatx': [1, 4.17, 0, 1],\n  'rMaty': [1, 4.17, 0, 1]},\n 'img_proc': {'subtract_bg': False,\n  'use_roi': False,\n  'avg_ims': True,\n  'n_to_acquire': 5,\n  'background_im': None,\n  'amp_threshold': 200,\n  'min_sigma': 2e-08,\n  'max_sigma': 0.1,\n  'max_samples': 3,\n  'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}},\n 'meas_pv_info': {'diagnostic': {'pv': {'name': 'OTRS:IN20:621',\n    'image': 'OTRS:IN20:621:IMAGE',\n    'nrow': 'OTRS:IN20:621:ROI_YNP',\n    'ncol': 'OTRS:IN20:621:ROI_XNP',\n    'resolution': 'OTRS:IN20:621:RESOLUTION',\n    'xsize': 'OTRS:IN20:621:XRMS',\n    'ysize': 'OTRS:IN20:621:YRMS'}},\n  'meas_device': {'settle_time': 1,\n   'bounds': [-2, 2],\n   'pv': {'name': 'QUAD:IN20:525',\n    'cntrl': 'QUAD:IN20:525:BCTRL',\n    'read': 'QUAD:IN20:525:BACT'}},\n  'beam_info': {'energy': 'REFS:IN20:751:EDES'}},\n 'savepaths': {'fits': '/home/physics3/ml_tuning/20220803/saved_fits/',\n  'images': '/home/physics3/ml_tuning/20220803/saved_images/',\n  'monitoring': '/home/physics3/ml_tuning/20220803/monitoring/',\n  'summaries': '/home/physics3/ml_tuning/20220803/summaries/',\n  'raw_saves': '/home/physics3/ml_tuning/20220803/raw_saves/',\n  'emit_saves': '/home/physics3/ml_tuning/20220803/emit_saves/',\n  'mon_saves': '/home/physics3/ml_tuning/20220803/mon_saves/',\n  'xopt_saves': '/home/physics3/ml_tuning/20220803/xopt_saves/'}}</pre>"},{"location":"examples/config_setup_example/#config-files-setup-for-epics-systems","title":"Config files setup for EPICS systems\u00b6","text":"<p>This notebook shows what config files you need and how to set them up.</p> <p>Note that this setup will be improved in the future to be only one json files with all machine information, removing the need for different directories</p>"},{"location":"examples/config_setup_example/#load-all-configs","title":"Load all configs\u00b6","text":"<p>This will load all files into a dict</p>"},{"location":"examples/image_analysis/","title":"Image analysis","text":"In\u00a0[1]: Copied! <pre>from pyemittance.image import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from pyemittance.image import Image import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre># get example data\nimage = np.load(\"./saved_images/1618446887_img.npy\", allow_pickle = True)\nncol = np.load(\"./saved_images/1618446887_ncol.npy\", allow_pickle = True)\nnrow = np.load(\"./saved_images/1618446887_nrow.npy\", allow_pickle = True)\n</pre> # get example data image = np.load(\"./saved_images/1618446887_img.npy\", allow_pickle = True) ncol = np.load(\"./saved_images/1618446887_ncol.npy\", allow_pickle = True) nrow = np.load(\"./saved_images/1618446887_nrow.npy\", allow_pickle = True) In\u00a0[3]: Copied! <pre># standard way to reshape the image array\nim = Image(image, ncol, nrow)\nim.reshape_im()\nprofx, profy = im.get_im_projection()\n</pre> # standard way to reshape the image array im = Image(image, ncol, nrow) im.reshape_im() profx, profy = im.get_im_projection() In\u00a0[4]: Copied! <pre>plt.imshow(im.proc_image)\n</pre> plt.imshow(im.proc_image) Out[4]: <pre>&lt;matplotlib.image.AxesImage at 0x7f6777f07970&gt;</pre> In\u00a0[5]: Copied! <pre>plt.plot(profx, label=\"x-profile\")\nplt.plot(profy, label=\"y-profile\")\nplt.legend()\n</pre> plt.plot(profx, label=\"x-profile\") plt.plot(profy, label=\"y-profile\") plt.legend() Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x7f676fd6c820&gt;</pre> In\u00a0[6]: Copied! <pre># returns: xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude\nfit_res = im.get_sizes(method = \"gaussian\", show_plots = True)\nxsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res\n</pre> # returns: xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude fit_res = im.get_sizes(method = \"gaussian\", show_plots = True) xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res In\u00a0[7]: Copied! <pre>from pyemittance.bs_fitting_methods import fit_gaussian_linear_background\n</pre> from pyemittance.bs_fitting_methods import fit_gaussian_linear_background In\u00a0[8]: Copied! <pre>fit_gaussian_linear_background(profx)\n</pre> fit_gaussian_linear_background(profx) Out[8]: <pre>(array([3217.84266293,  185.43343034,    7.45136335]),\n array([104.61474965,   0.27784605,   0.28365575]))</pre> In\u00a0[9]: Copied! <pre>fit_gaussian_linear_background(profy)\n</pre> fit_gaussian_linear_background(profy) Out[9]: <pre>(array([1991.90020444,  146.34583081,   11.56409759]),\n array([44.40883484,  0.29357206,  0.30790032]))</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/image_analysis/#image-analysis","title":"Image analysis\u00b6","text":"<p>example + adding fitting methods</p>"},{"location":"examples/image_analysis/#example-of-how-this-is-called-in-pyemittance","title":"Example of how this is called in pyemittance\u00b6","text":""},{"location":"examples/image_analysis/#gaussian-linear-bg-function-example","title":"Gaussian + linear bg function example\u00b6","text":""},{"location":"examples/image_analysis/#adding-a-fitting-method","title":"Adding a fitting method:\u00b6","text":""},{"location":"examples/image_analysis/#need-to-write-an-asymmetric-gaussian-linear-bg-function-to-import-as","title":"Need to write an asymmetric Gaussian + linear bg function to import as:\u00b6","text":"<p>fit_asym_gaussian_linear_background</p>"},{"location":"examples/image_analysis/#and-to-pass-an-array-like-in-the-cell-above-and-return-a-fit-with-the-results","title":"and to pass an array like in the cell above and return a fit with the results:\u00b6","text":"<p>size (Gaussian width), error on the size, and the amplitude</p>"},{"location":"examples/simulated_epics/","title":"Beam Simulator and EPICS server","text":"In\u00a0[\u00a0]: Copied! <pre>from pyemittance.simulation_server import start_server\nfrom pyemittance import print_logging\nimport logging\nprint_logging(level=10)\n\nstart_server(config_name='LCLS2_OTR0H04')\n</pre> from pyemittance.simulation_server import start_server from pyemittance import print_logging import logging print_logging(level=10)  start_server(config_name='LCLS2_OTR0H04') <pre>2023-08-28 15:58:04,993 | INFO : Initialized config: LCLS2_OTR0H04\n2023-08-28 15:58:04,995 | INFO : Serving: ['QUAD:HTR:120:BCTRL', 'QUAD:HTR:120:BACT', 'OTRS:HTR:330:Image:ArrayData', 'OTRS:HTR:330:Image:ArraySize1_RBV', 'OTRS:HTR:330:Image:ArraySize0_RBV', 'OTRS:HTR:330:RESOLUTION', 'sim_screen_sigma_x', 'sim_screen_sigma_y']\n2023-08-28 15:58:14,563 | INFO : Setting QUAD:HTR:120:BCTRL =  -6.0\n2023-08-28 15:58:14,972 | INFO : Setting QUAD:HTR:120:BCTRL =  -4.0\n2023-08-28 15:58:15,281 | INFO : Setting QUAD:HTR:120:BCTRL =  -2.0\n2023-08-28 15:58:15,580 | INFO : Setting QUAD:HTR:120:BCTRL =  0.0\n2023-08-28 15:58:15,881 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.7091934770995062\n2023-08-28 15:58:16,183 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.1743278975829219\n2023-08-28 15:58:16,513 | INFO : Setting QUAD:HTR:120:BCTRL =  0.3605376819336624\n2023-08-28 15:58:16,820 | INFO : Setting QUAD:HTR:120:BCTRL =  0.8954032614502466\n2023-08-28 15:58:17,113 | INFO : Setting QUAD:HTR:120:BCTRL =  1.4302688409668312\n2023-08-28 15:58:17,417 | INFO : Setting QUAD:HTR:120:BCTRL =  1.9651344204834156\n2023-08-28 15:58:17,717 | INFO : Setting QUAD:HTR:120:BCTRL =  2.5\n2023-08-28 15:58:18,049 | INFO : Setting QUAD:HTR:120:BCTRL =  -1.8354391121594031\n2023-08-28 15:58:18,349 | INFO : Setting QUAD:HTR:120:BCTRL =  -1.1128659267995027\n2023-08-28 15:58:18,648 | INFO : Setting QUAD:HTR:120:BCTRL =  -0.39029274143960224\n2023-08-28 15:58:18,945 | INFO : Setting QUAD:HTR:120:BCTRL =  1.0548536292801987\n2023-08-28 15:58:19,235 | INFO : Setting QUAD:HTR:120:BCTRL =  1.777426814640099\n2023-08-28 15:58:19,576 | INFO : Setting QUAD:HTR:120:BCTRL =  2.958456211014215\n2023-08-28 15:58:19,878 | INFO : Setting QUAD:HTR:120:BCTRL =  3.5697311590331684\n2023-08-28 15:58:20,172 | INFO : Setting QUAD:HTR:120:BCTRL =  4.181006107052122\n2023-08-28 15:58:20,471 | INFO : Setting QUAD:HTR:120:BCTRL =  4.792281055071076\n2023-08-28 15:58:20,771 | INFO : Setting QUAD:HTR:120:BCTRL =  3.1193484445942\n2023-08-28 15:58:21,078 | INFO : Setting QUAD:HTR:120:BCTRL =  3.9451463707198005\n2023-08-28 15:58:21,424 | INFO : Setting QUAD:HTR:120:BCTRL =  5.5967422229710015\n2023-08-28 15:58:22,340 | INFO : Setting QUAD:HTR:120:BCTRL =  1.2345\n2023-08-28 15:58:22,893 | INFO : Setting QUAD:HTR:120:BCTRL =  0.0\n</pre>"},{"location":"examples/simulated_epics/#beam-simulator-and-epics-server","title":"Beam Simulator and EPICS server\u00b6","text":"<p>Run this cell to start the server.</p> <p>Then try on the command line:</p> <pre><code>caput QUAD:HTR:120:BCTRL 1.234\ncaget QUAD:HTR:120:BACT\n</code></pre>"},{"location":"examples/simulated_online/","title":"Online PyEmittance","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pyemittance import PyEmittance, print_logging\nimport numpy as np\nprint_logging() # Print log messages here\n</pre> from pyemittance import PyEmittance, print_logging import numpy as np print_logging() # Print log messages here In\u00a0[3]: Copied! <pre>meas = PyEmittance(config_name='LCLS2_OTR0H04')\nmeas.online = True\n\n# Set some other options\nmeas.add_pnts = False\nmeas.num_points = 7   # only matters if adapt_ranges is used.\nmeas.adapt_ranges = True  # If helping, will ensure there are at least 7 total points\nmeas.check_sym = True\nmeas.infl_check = True\n\nmeas.show_plots = True\n\n# Change quad bounds\nmeas.config_dict['meas_pv_info']['meas_device']['bounds'] = [-6, 8]\n\n# Change settle time\nmeas.config_dict['meas_pv_info']['meas_device']['settle_time'] = 0.1\n\nmeas.config_dict\n</pre> meas = PyEmittance(config_name='LCLS2_OTR0H04') meas.online = True  # Set some other options meas.add_pnts = False meas.num_points = 7   # only matters if adapt_ranges is used. meas.adapt_ranges = True  # If helping, will ensure there are at least 7 total points meas.check_sym = True meas.infl_check = True  meas.show_plots = True  # Change quad bounds meas.config_dict['meas_pv_info']['meas_device']['bounds'] = [-6, 8]  # Change settle time meas.config_dict['meas_pv_info']['meas_device']['settle_time'] = 0.1  meas.config_dict  <pre>2023-09-02 16:00:09,852 | INFO : Initializing observer\n</pre> Out[3]: <pre>{'beamline_info': {'name': 'LCLS2',\n  'species': 'electron',\n  'Lquad': 0.1244,\n  'energy': 80000000.0,\n  'Twiss0': [1e-06, 1e-06, 5.01, 5.01, 0.049, 0.049],\n  'rMatx': [1, 2.2, 0, 1],\n  'rMaty': [1, 2.2, 0, 1]},\n 'img_proc': {'subtract_bg': False,\n  'use_roi': False,\n  'avg_ims': True,\n  'n_to_acquire': 1,\n  'background_im': '/home/physics3/ml_tuning/20220805_LCLS2_inj/example_images/bg_8_6_22.npy',\n  'amp_threshold': 150,\n  'min_sigma': 3,\n  'max_sigma': 700,\n  'max_samples': 1,\n  'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}},\n 'meas_pv_info': {'diagnostic': {'pv': {'name': 'OTRS:HTR:330',\n    'image': 'OTRS:HTR:330:Image:ArrayData',\n    'nrow': 'OTRS:HTR:330:Image:ArraySize1_RBV',\n    'ncol': 'OTRS:HTR:330:Image:ArraySize0_RBV',\n    'resolution': 'OTRS:HTR:330:RESOLUTION',\n    'xsize': 'OTRS:HTR:330:XRMS',\n    'ysize': 'OTRS:HTR:330:YRMS'}},\n  'meas_device': {'settle_time': 0.1,\n   'bounds': [-6, 8],\n   'pv': {'name': 'QUAD:HTR:120',\n    'cntrl': 'QUAD:HTR:120:BCTRL',\n    'read': 'QUAD:HTR:120:BACT'}},\n  'beam_info': {'energy': ''}},\n 'savepaths': {'fits': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/saved_fits/',\n  'images': None,\n  'monitoring': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/monitoring/',\n  'summaries': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/summaries/',\n  'raw_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/raw_saves/',\n  'emit_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/emit_saves/',\n  'mon_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/mon_saves/',\n  'xopt_saves': '/home/physics3/ml_tuning/20220805_LCLS2_inj/data_saving/xopt_saves/'}}</pre> In\u00a0[4]: Copied! <pre>meas.observer.get_beamsizes(1.2345)\n</pre> meas.observer.get_beamsizes(1.2345) Out[4]: <pre>{'xrms': 0.0002856050839798949,\n 'yrms': 0.0002720644153953202,\n 'xrms_err': 0,\n 'yrms_err': 0}</pre> In\u00a0[5]: Copied! <pre># Convenience methods.\nmeas.quad_init, meas.quad_bounds\n</pre> # Convenience methods. meas.quad_init, meas.quad_bounds Out[5]: <pre>([-6, -4, -2, 0], [-6, 8])</pre> In\u00a0[6]: Copied! <pre>meas.config_dict.keys()\n</pre> meas.config_dict.keys() Out[6]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[7]: Copied! <pre>meas.config_dict['meas_pv_info']['meas_device']\n</pre> meas.config_dict['meas_pv_info']['meas_device'] Out[7]: <pre>{'settle_time': 0.1,\n 'bounds': [-6, 8],\n 'pv': {'name': 'QUAD:HTR:120',\n  'cntrl': 'QUAD:HTR:120:BCTRL',\n  'read': 'QUAD:HTR:120:BACT'}}</pre> In\u00a0[8]: Copied! <pre>meas.config_dict['img_proc']\n</pre> meas.config_dict['img_proc'] Out[8]: <pre>{'subtract_bg': False,\n 'use_roi': False,\n 'avg_ims': True,\n 'n_to_acquire': 1,\n 'background_im': '/home/physics3/ml_tuning/20220805_LCLS2_inj/example_images/bg_8_6_22.npy',\n 'amp_threshold': 150,\n 'min_sigma': 3,\n 'max_sigma': 700,\n 'max_samples': 1,\n 'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}}</pre> In\u00a0[9]: Copied! <pre>result = meas.measure_emittance()\n</pre> result = meas.measure_emittance() <pre>2023-09-02 16:00:10,019 | INFO : Initializing observer\n2023-09-02 16:00:10,021 | INFO : Running online!\n2023-09-02 16:00:10,022 | INFO : EPICS put QUAD:HTR:120:BCTRL = -6\n2023-09-02 16:00:10,023 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:11,046 | INFO : 2023-09-02_16-00-11-046232\n[&lt;pyemittance.image.Image object at 0x7f1087433790&gt;]\n2023-09-02 16:00:11,276 | INFO : EPICS put QUAD:HTR:120:BCTRL = -4\n2023-09-02 16:00:11,278 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:11,773 | INFO : 2023-09-02_16-00-11-773604\n[&lt;pyemittance.image.Image object at 0x7f1087433790&gt;, &lt;pyemittance.image.Image object at 0x7f108634daf0&gt;]\n2023-09-02 16:00:11,941 | INFO : EPICS put QUAD:HTR:120:BCTRL = -2\n2023-09-02 16:00:11,943 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:12,441 | INFO : 2023-09-02_16-00-12-441863\n[&lt;pyemittance.image.Image object at 0x7f1087433790&gt;, &lt;pyemittance.image.Image object at 0x7f108634daf0&gt;, &lt;pyemittance.image.Image object at 0x7f10bc491af0&gt;]\n2023-09-02 16:00:12,596 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0\n2023-09-02 16:00:12,598 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:13,067 | INFO : 2023-09-02_16-00-13-067086\n[&lt;pyemittance.image.Image object at 0x7f1087433790&gt;, &lt;pyemittance.image.Image object at 0x7f108634daf0&gt;, &lt;pyemittance.image.Image object at 0x7f10bc491af0&gt;, &lt;pyemittance.image.Image object at 0x7f1085f6d130&gt;]\n2023-09-02 16:00:13,230 | INFO : Adapting ranges\n2023-09-02 16:00:13,234 | INFO : Adapting ranges for x beam size measurement: [-0.725921460376747, -0.1882678836472892, 0.3493856930821686, 0.8870392698116265, 1.4246928465410842, 1.9623464232705419, 2.5]\n2023-09-02 16:00:13,235 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.725921460376747\n2023-09-02 16:00:13,236 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:13,722 | INFO : 2023-09-02_16-00-13-722030\n2023-09-02 16:00:13,890 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.1882678836472892\n2023-09-02 16:00:13,892 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:14,416 | INFO : 2023-09-02_16-00-14-416095\n2023-09-02 16:00:14,577 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0.3493856930821686\n2023-09-02 16:00:14,580 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:15,049 | INFO : 2023-09-02_16-00-15-049367\n2023-09-02 16:00:15,212 | INFO : EPICS put QUAD:HTR:120:BCTRL = 0.8870392698116265\n2023-09-02 16:00:15,215 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:15,748 | INFO : 2023-09-02_16-00-15-748219\n2023-09-02 16:00:15,903 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.4246928465410842\n2023-09-02 16:00:15,905 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:16,369 | INFO : 2023-09-02_16-00-16-369151\n2023-09-02 16:00:16,525 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.9623464232705419\n2023-09-02 16:00:16,527 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:16,990 | INFO : 2023-09-02_16-00-16-990638\n2023-09-02 16:00:17,151 | INFO : EPICS put QUAD:HTR:120:BCTRL = 2.5\n2023-09-02 16:00:17,154 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:17,731 | INFO : 2023-09-02_16-00-17-731145\n2023-09-02 16:00:17,898 | INFO : Adapting ranges for y beam size measurement: [-1.811576315025631, -1.0929802625213592, -0.3743842100170873, 0.3442118424871845, 1.0628078949914563, 1.7814039474957282, 2.5]\n2023-09-02 16:00:17,900 | INFO : EPICS put QUAD:HTR:120:BCTRL = -1.811576315025631\n2023-09-02 16:00:17,901 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:18,383 | INFO : 2023-09-02_16-00-18-383328\n2023-09-02 16:00:18,537 | INFO : EPICS put QUAD:HTR:120:BCTRL = -1.0929802625213592\n2023-09-02 16:00:18,540 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:19,021 | INFO : 2023-09-02_16-00-19-021105\n2023-09-02 16:00:19,182 | INFO : EPICS put QUAD:HTR:120:BCTRL = -0.3743842100170873\n2023-09-02 16:00:19,183 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:19,666 | INFO : 2023-09-02_16-00-19-666574\n2023-09-02 16:00:19,835 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.0628078949914563\n2023-09-02 16:00:19,837 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:20,302 | INFO : 2023-09-02_16-00-20-302784\n2023-09-02 16:00:20,588 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.7814039474957282\n2023-09-02 16:00:20,591 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:21,069 | INFO : 2023-09-02_16-00-21-069003\n2023-09-02 16:00:21,071 | INFO : Beam params out of bounds in image 0 out of 1 samples\n2023-09-02 16:00:21,234 | INFO : Resampled 0 times (max_samples = 1, beam still out of bounds \n\n2023-09-02 16:00:21,238 | INFO : xrms 57.62 um, yrms 708.39 um (threshold: min_rms 60.60 um, max_rms 14140.00 um)\n2023-09-02 16:00:21,240 | INFO : xamp 699418.11, yamp 56932.53 (amp_thresh: 150, in json)\n2023-09-02 16:00:21,241 | INFO : area_x 104912717.2, area_y 8539879.0 (threshold: 1500, hardcoded)\n\n2023-09-02 16:00:21,243 | INFO : Returning NaNs\n2023-09-02 16:00:21,245 | INFO : Checking symmetry\n2023-09-02 16:00:21,247 | INFO : EPICS put QUAD:HTR:120:BCTRL = 2.960845922910964\n2023-09-02 16:00:21,254 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:21,739 | INFO : 2023-09-02_16-00-21-738973\n2023-09-02 16:00:21,918 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.575307153458916\n2023-09-02 16:00:21,920 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:22,377 | INFO : 2023-09-02_16-00-22-377582\n2023-09-02 16:00:22,535 | INFO : EPICS put QUAD:HTR:120:BCTRL = 4.189768384006868\n2023-09-02 16:00:22,539 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:23,001 | INFO : 2023-09-02_16-00-23-001832\n2023-09-02 16:00:23,170 | INFO : EPICS put QUAD:HTR:120:BCTRL = 4.80422961455482\n2023-09-02 16:00:23,174 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:23,642 | INFO : 2023-09-02_16-00-23-642348\n2023-09-02 16:00:23,804 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.1159394735750903\n2023-09-02 16:00:23,806 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:24,280 | INFO : 2023-09-02_16-00-24-280537\n2023-09-02 16:00:24,600 | INFO : EPICS put QUAD:HTR:120:BCTRL = 3.9371921050085437\n2023-09-02 16:00:24,603 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:25,075 | INFO : 2023-09-02_16-00-25-075346\n2023-09-02 16:00:25,231 | INFO : EPICS put QUAD:HTR:120:BCTRL = 5.5796973678754505\n2023-09-02 16:00:25,233 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:25,734 | INFO : 2023-09-02_16-00-25-734743\n2023-09-02 16:00:25,893 | INFO : Checking inflection\n2023-09-02 16:00:25,895 | INFO : Emmitance calc for 11 x points, 11 y points\n</pre> In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[11]: Copied! <pre>result\n</pre> result Out[11]: <pre>{'quadvalsx': array([-0.72592146, -0.18826788,  0.34938569,  0.88703927,  1.42469285,\n         1.96234642,  2.5       ,  2.96084592,  3.57530715,  4.18976838,\n         4.80422961]),\n 'beamsizesx': array([5.31078936e-04, 4.16967250e-04, 3.00199679e-04, 1.87642596e-04,\n        8.65015138e-05, 7.40842698e-05, 1.71003369e-04, 2.62990146e-04,\n        3.89370174e-04, 5.15351284e-04, 6.37011245e-04]),\n 'beamsizeserrx': array([6.23146215e-07, 3.90894651e-07, 2.63595986e-07, 1.18694232e-07,\n        2.89670715e-08, 3.39773933e-08, 9.45749799e-08, 1.97634824e-07,\n        3.77245628e-07, 5.77603650e-07, 8.91494299e-07]),\n 'error_x': False,\n 'emit_x': 6.380225302143409e-09,\n 'norm_emit_x': 9.988427795017674e-07,\n 'beta_x': 10.028119862136135,\n 'alpha_x': -2.0149667431522307,\n 'emit_x_err': 3.584955433519756e-12,\n 'norm_emit_x_err': 5.612351727459969e-10,\n 'beta_x_rel_err': 0.000561885398046273,\n 'alpha_x_rel_err': -3.2106833809592616e-20,\n 'sigma_11': 6.398166407732784e-08,\n 'sigma_12': 1.2855941797637363e-08,\n 'sigma_22': 3.219399141625969e-09,\n 'screen_sigma_11': array([2.83971546e-07, 1.73221599e-07, 9.06662915e-08, 3.56348101e-08,\n        7.46511500e-09, 5.50386039e-09, 2.91063180e-08, 6.92011534e-08,\n        1.50466086e-07, 2.62660888e-07, 4.04874363e-07]),\n 'screen_sigma_12': array([ 6.55439337e-08,  2.98877193e-08,  6.59080634e-09, -4.64501801e-09,\n        -4.11404248e-09,  7.89333347e-09,  3.10905651e-08,  5.96657053e-08,\n         1.09927484e-07,  1.73711680e-07,  2.50613466e-07]),\n 'screen_sigma_22': array([1.52716516e-08, 5.39183937e-09, 9.28084757e-10, 1.74782655e-09,\n        7.72025889e-09, 1.87163156e-08, 3.46086547e-08, 5.20324227e-08,\n        8.05813407e-08, 1.15039797e-07, 1.55227948e-07]),\n 'quadvalsy': array([-1.81157632, -1.09298026, -0.37438421,  0.34421184,  1.06280789,\n         2.5       ,  3.11593947,  3.93719211,  4.75844474,  5.57969737]),\n 'beamsizesy': array([0.00171271, 0.00151594, 0.0013238 , 0.00110886, 0.00091245,\n        0.0004951 , 0.00031929, 0.00010643, 0.00022087, 0.00044845]),\n 'beamsizeserry': array([4.42851438e-06, 3.80479429e-06, 3.08277465e-06, 2.46012153e-06,\n        1.61680594e-06, 7.53839455e-07, 3.65935103e-07, 4.77619333e-08,\n        1.74149531e-07, 4.92537533e-07]),\n 'error_y': False,\n 'emit_y': 1.3751948236228059e-08,\n 'norm_emit_y': 2.152907389528063e-06,\n 'beta_y': 10.397064147488576,\n 'alpha_y': 18.80069944220473,\n 'emit_y_err': 1.344717956408853e-11,\n 'norm_emit_y_err': 2.105194969798521e-09,\n 'beta_y_rel_err': 0.000977838145772363,\n 'alpha_y_rel_err': 2.804075932518792e-19,\n 'sigma_33': 1.4297988796500551e-07,\n 'sigma_34': -2.585462455340812e-07,\n 'sigma_44': 4.688441018814357e-07,\n 'screen_sigma_33': array([2.96366364e-06, 2.31644175e-06, 1.74285170e-06, 1.24574977e-06,\n        8.28046203e-07, 2.42748957e-07, 9.87886497e-08, 1.13466513e-08,\n        4.77042107e-08, 2.12716246e-07]),\n 'screen_sigma_34': array([ 1.56456893e-06,  1.24908096e-06,  9.65716734e-07,  7.15744832e-07,\n         5.00457982e-07,  1.79232797e-07,  8.83277978e-08,  1.28770548e-08,\n        -8.34102735e-09,  2.68316655e-08]),\n 'screen_sigma_44': array([8.26026617e-07, 6.73616062e-07, 5.35213596e-07, 4.11382601e-07,\n        3.02697249e-07, 1.33114935e-07, 8.08890087e-08, 3.12810019e-08,\n        5.42276696e-09, 4.27355394e-09]),\n 'sqrt_norm_emit_4d': 1.4664296781523841e-06,\n 'sqrt_norm_emit_4d_err': 1.6538067541652102e-09}</pre> In\u00a0[12]: Copied! <pre>plt.plot(result['quadvalsx'], np.sqrt(result['screen_sigma_11']))\nplt.plot(result['quadvalsx'], result['beamsizesx'], marker='x')\n</pre> plt.plot(result['quadvalsx'], np.sqrt(result['screen_sigma_11'])) plt.plot(result['quadvalsx'], result['beamsizesx'], marker='x') Out[12]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f105b7ef1c0&gt;]</pre> In\u00a0[13]: Copied! <pre>plt.plot(result['quadvalsy'], np.sqrt(result['screen_sigma_33']))\nplt.plot(result['quadvalsy'], result['beamsizesy'], marker='x')\n</pre> plt.plot(result['quadvalsy'], np.sqrt(result['screen_sigma_33'])) plt.plot(result['quadvalsy'], result['beamsizesy'], marker='x') Out[13]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f105b8b12b0&gt;]</pre> In\u00a0[14]: Copied! <pre>o = meas.observer\no.beam_meas['x']\n</pre> o = meas.observer o.beam_meas['x'] Out[14]: <pre>[0.0017319965094041647,\n 0.0012677116067485394,\n 0.0008156152128438839,\n 0.0007717229143932074,\n 0.0006109280395657084,\n 0.0005310789363652958,\n 0.0004565024520392191,\n 0.00041696725034169694,\n 0.00037389685405919346,\n 0.0003001996785587896,\n 0.00018764259633947025,\n 0.0001527761765133468,\n 8.650151376800355e-05,\n nan,\n 7.408426981944035e-05,\n 0.0001710033694494241,\n 0.0002629901458582531,\n 0.00029583871423323097,\n 0.0003893701741397189,\n 0.0004609075071683442,\n 0.0005153512835542348,\n 0.0006370112451163578,\n 0.0007952563299734706]</pre> In\u00a0[15]: Copied! <pre># Note that this was a problematic image\nix_nan = np.where(np.isnan(o.beam_meas['x']))[0][0]\nix_nan\n</pre> # Note that this was a problematic image ix_nan = np.where(np.isnan(o.beam_meas['x']))[0][0] ix_nan Out[15]: <pre>13</pre> In\u00a0[16]: Copied! <pre># This is the image\no.extra[ix_nan].get_sizes()\n</pre> # This is the image o.extra[ix_nan].get_sizes() Out[16]: <pre>{'xrms': 2.8522865575268885,\n 'yrms': 35.06890802299145,\n 'xrms_err': 0.0010253071845839176,\n 'yrms_err': 0.05845542290783643,\n 'xamp': 699418.1145178082,\n 'yamp': 56932.52655505132}</pre> In\u00a0[17]: Copied! <pre># The observer can also set the quad and return sizes (and extra image).\ndat = o.get_beamsizes(1.2345)\ndat\n</pre> # The observer can also set the quad and return sizes (and extra image). dat = o.get_beamsizes(1.2345) dat <pre>2023-09-02 16:00:27,428 | INFO : EPICS put QUAD:HTR:120:BCTRL = 1.2345\n2023-09-02 16:00:27,430 | INFO : Settling for 0.1 s...\n2023-09-02 16:00:27,895 | INFO : 2023-09-02_16-00-27-895549\n</pre> Out[17]: <pre>{'xrms': 0.00012047477546215778,\n 'yrms': 0.0008570228573263447,\n 'xrms_err': 5.86217973346717e-08,\n 'yrms_err': 1.528657218869215e-06,\n 'extra': &lt;pyemittance.image.Image at 0x7f105b696400&gt;}</pre> In\u00a0[18]: Copied! <pre># This is the image\nim = dat['extra']\nim\n</pre> # This is the image im = dat['extra'] im Out[18]: <pre>&lt;pyemittance.image.Image at 0x7f105b696400&gt;</pre> In\u00a0[19]: Copied! <pre># This plots. TODO: make a .plot() instead\nim.get_sizes()\n</pre> # This plots. TODO: make a .plot() instead im.get_sizes() Out[19]: <pre>{'xrms': 5.964097795156326,\n 'yrms': 42.42687412506657,\n 'xrms_err': 0.0029020691749837477,\n 'yrms_err': 0.07567609994402054,\n 'xamp': 334856.0390775527,\n 'yamp': 46946.04587345442}</pre> In\u00a0[20]: Copied! <pre>import epics\nimport matplotlib.pyplot as plt\n\nfrom ipywidgets import interact\n\ndef f(quad_value):\n    epics.caput('QUAD:HTR:120:BCTRL', quad_value)\n    a = epics.caget('OTRS:HTR:330:Image:ArrayData').reshape(1040, 1392)\n    sigma_x = epics.caget('sim_screen_sigma_x')\n    sigma_y = epics.caget('sim_screen_sigma_y')  \n    print(sigma_x)\n    plt.imshow(a, vmax=128)\n    plt.title(f'sim sigma_x, y = {sigma_x*1e3:0.3f}    {sigma_y*1e3:0.3f} mm')\n    \n# interact(f, quad_value=(-4, 4, .1))    \nf(0)\n</pre> import epics import matplotlib.pyplot as plt  from ipywidgets import interact  def f(quad_value):     epics.caput('QUAD:HTR:120:BCTRL', quad_value)     a = epics.caget('OTRS:HTR:330:Image:ArrayData').reshape(1040, 1392)     sigma_x = epics.caget('sim_screen_sigma_x')     sigma_y = epics.caget('sim_screen_sigma_y')       print(sigma_x)     plt.imshow(a, vmax=128)     plt.title(f'sim sigma_x, y = {sigma_x*1e3:0.3f}    {sigma_y*1e3:0.3f} mm')      # interact(f, quad_value=(-4, 4, .1))     f(0) <pre>0.00037486171231124573\n</pre>"},{"location":"examples/simulated_online/#online-pyemittance","title":"Online PyEmittance\u00b6","text":"<p>The following will work either on a production system, or with a simulated EPICS server.</p> <p>For local development, start a simulated EPICS server using the <code>simulated_epics.ipynb</code> notebook, or run in a separate process:</p> <pre>from pyemittance.simulation_server import start_server\nstart_server()\n</pre>"},{"location":"examples/simulated_online/#examine-results","title":"Examine results\u00b6","text":""},{"location":"examples/simulated_online/#observer","title":"Observer\u00b6","text":"<p>The observer keeps all measurements made, as well as extra information such as images.</p>"},{"location":"examples/simulated_online/#interactively-change-the-quad-and-acquire-the-screen-image","title":"Interactively change the quad and acquire the screen image\u00b6","text":""},{"location":"examples/simulated_quad_scan/","title":"Simulated Quad Scan","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pyemittance.emittance_calc import EmitCalc\nfrom pyemittance.load_json_configs import load_configs\n</pre> import numpy as np import matplotlib.pyplot as plt from pyemittance.emittance_calc import EmitCalc from pyemittance.load_json_configs import load_configs <p>Load this config and add a drift.</p> In\u00a0[3]: Copied! <pre>CONFIG = load_configs('LCLS2_OTR0H04')\nCONFIG['beamline_info']\n</pre> CONFIG = load_configs('LCLS2_OTR0H04') CONFIG['beamline_info'] Out[3]: <pre>{'name': 'LCLS2',\n 'species': 'electron',\n 'Lquad': 0.1244,\n 'energy': 80000000.0,\n 'Twiss0': [1e-06, 1e-06, 5.01, 5.01, 0.049, 0.049],\n 'rMatx': [1, 2.2, 0, 1],\n 'rMaty': [1, 2.2, 0, 1]}</pre> In\u00a0[4]: Copied! <pre>from pyemittance.simulation import BeamSim\n</pre> from pyemittance.simulation import BeamSim In\u00a0[5]: Copied! <pre>BUNCH_PARAMS0 = {\n    'total_charge': 50e-12,\n    'norm_emit_x': 1e-6,\n    'norm_emit_y': 2e-6,\n    'beta_x': 10,\n    'alpha_x': -1,\n    'beta_y': 11,\n    'alpha_y': -2,\n    'energy': 80e6,\n    'species':'electron'\n}\n</pre> BUNCH_PARAMS0 = {     'total_charge': 50e-12,     'norm_emit_x': 1e-6,     'norm_emit_y': 2e-6,     'beta_x': 10,     'alpha_x': -1,     'beta_y': 11,     'alpha_y': -2,     'energy': 80e6,     'species':'electron' } <p>Create the simulation</p> In\u00a0[6]: Copied! <pre>sim = BeamSim(bunch_params=BUNCH_PARAMS0, beamline_info=CONFIG['beamline_info'])\n</pre> sim = BeamSim(bunch_params=BUNCH_PARAMS0, beamline_info=CONFIG['beamline_info']) In\u00a0[7]: Copied! <pre>sim.screen_sigma('x'), sim.screen_sigma('y')\n</pre> sim.screen_sigma('x'), sim.screen_sigma('y') Out[7]: <pre>(0.000316975039076531, 0.0005391478973939177)</pre> <p>Set the scanning quadrupole (in machine units) and get the x and y beam sizes</p> In\u00a0[8]: Copied! <pre>sim.quad_value = 2\nsim.screen_beam_sizes()\n</pre> sim.quad_value = 2 sim.screen_beam_sizes() Out[8]: <pre>(0.00012627736478842047, 0.0011887442162668135)</pre> In\u00a0[9]: Copied! <pre>sim.plot_screen()\n</pre> sim.plot_screen() <p>Set the noise level. This just adds random numbers with a maximum value of this level.</p> In\u00a0[10]: Copied! <pre>sim.screen.noise=50\nsim.plot_screen()\n</pre> sim.screen.noise=50 sim.plot_screen() <p>Simple interaction</p> In\u00a0[11]: Copied! <pre>from ipywidgets import interact\n\ndef f(quad_value):\n    sim.quad_value = quad_value\n    sim.plot_screen()\n  \nf(1)\n\n# interact(f, quad_value=(-4, 4, .1), vmax=128)\n</pre> from ipywidgets import interact  def f(quad_value):     sim.quad_value = quad_value     sim.plot_screen()    f(1)  # interact(f, quad_value=(-4, 4, .1), vmax=128) In\u00a0[12]: Copied! <pre>quad_vals = np.linspace(-2,2, 20)\nmeas =  np.array([sim.beam_size_meas(v) for v in quad_vals])\nmeas_x = meas[:,0]\nmeas_y = meas[:,1]\n</pre> quad_vals = np.linspace(-2,2, 20) meas =  np.array([sim.beam_size_meas(v) for v in quad_vals]) meas_x = meas[:,0] meas_y = meas[:,1] In\u00a0[13]: Copied! <pre>plt.plot(quad_vals, meas_x*1e3, label='x')\nplt.plot(quad_vals, meas_y*1e3, label='y')\nplt.xlabel('quad value (machine units)')\nplt.ylabel('Beam size (mm)')\nplt.legend()\n</pre> plt.plot(quad_vals, meas_x*1e3, label='x') plt.plot(quad_vals, meas_y*1e3, label='y') plt.xlabel('quad value (machine units)') plt.ylabel('Beam size (mm)') plt.legend() Out[13]: <pre>&lt;matplotlib.legend.Legend at 0x1283f4a90&gt;</pre> In\u00a0[14]: Copied! <pre>ef = EmitCalc({'x': quad_vals,'y': quad_vals},\n              {'x': meas_x ,'y': meas_y},\n              {'x': meas_x*0.03 ,'y': meas_y*0.03},\n              config_dict=CONFIG,\n             )\n\nef.plot = True             \nresult = ef.get_emit()\n\nresult['norm_emit_x'], result['norm_emit_y'], result['beta_x'], result['beta_y'], result['alpha_x'], result['alpha_y']\n</pre> ef = EmitCalc({'x': quad_vals,'y': quad_vals},               {'x': meas_x ,'y': meas_y},               {'x': meas_x*0.03 ,'y': meas_y*0.03},               config_dict=CONFIG,              )  ef.plot = True              result = ef.get_emit()  result['norm_emit_x'], result['norm_emit_y'], result['beta_x'], result['beta_y'], result['alpha_x'], result['alpha_y'] Out[14]: <pre>(9.999999999999995e-07,\n 2.0000000000000046e-06,\n 10.0,\n 10.99999999999998,\n -1.0,\n -1.9999999999999951)</pre> In\u00a0[15]: Copied! <pre>print(ef.summary())\n</pre> print(ef.summary()) <pre>\"\n    Emittance Calculation Summary\n    \n    Emittance x: 1.000 +/- 0.022 mm mrad\n    Emittance y: 2.000 +/- 0.046 mm mrad\n    \n    Before scanning quad:\n                    x        y\n    norm_emit      1.00      2.00 (mm-mrad)                    \n    beta          10.00     11.00 (m)\n    alpha         -1.00     -2.00 (1)\n\n    \n    \n</pre> In\u00a0[16]: Copied! <pre>sim.quad_value = -2\nsim.plot_screen()\n</pre> sim.quad_value = -2 sim.plot_screen() <p>Get a raw image. Note that images are always (row, column), in image coordinates (0,0) is in the top left).</p> In\u00a0[17]: Copied! <pre>im = sim.screen_image()\nim.shape\n</pre> im = sim.screen_image() im.shape Out[17]: <pre>(1040, 1392)</pre> <p>These are the true beam sizes</p> In\u00a0[18]: Copied! <pre>sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes()\n</pre> sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes() In\u00a0[19]: Copied! <pre>from pyemittance.image import Image\n</pre> from pyemittance.image import Image In\u00a0[20]: Copied! <pre>raw_im = sim.screen_image()\nim = Image(raw_im,  sim.screen.nrow, sim.screen.ncol)\nim.reshape_im()\nplt.imshow(im.proc_image, vmax=128)\n</pre> raw_im = sim.screen_image() im = Image(raw_im,  sim.screen.nrow, sim.screen.ncol) im.reshape_im() plt.imshow(im.proc_image, vmax=128) Out[20]: <pre>&lt;matplotlib.image.AxesImage at 0x15621cb80&gt;</pre> In\u00a0[21]: Copied! <pre>profx, profy = im.get_im_projection()\nplt.plot(profx, label=\"x-profile\")\nplt.plot(profy, label=\"y-profile\")\nplt.legend()\n</pre> profx, profy = im.get_im_projection() plt.plot(profx, label=\"x-profile\") plt.plot(profy, label=\"y-profile\") plt.legend() Out[21]: <pre>&lt;matplotlib.legend.Legend at 0x156293bb0&gt;</pre> In\u00a0[22]: Copied! <pre>fit_res = im.get_sizes(method = \"gaussian\", show_plots = True)\nxsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res\n</pre> fit_res = im.get_sizes(method = \"gaussian\", show_plots = True) xsize, ysize, xsize_error, ysize_error, x_amplitude, y_amplitude = fit_res In\u00a0[23]: Copied! <pre>sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes()\nresolution = sim.screen.resolution\n\nmeas_sigma_x = xsize * resolution\nmeas_sigma_y = ysize * resolution\n</pre> sim_sigma_x, sim_sigma_y = sim.screen_beam_sizes() resolution = sim.screen.resolution  meas_sigma_x = xsize * resolution meas_sigma_y = ysize * resolution <p>These agree fairly well:</p> In\u00a0[24]: Copied! <pre>meas_sigma_x/sim_sigma_x\n</pre> meas_sigma_x/sim_sigma_x Out[24]: <pre>1.0005703025910728</pre> In\u00a0[25]: Copied! <pre>meas_sigma_y/sim_sigma_y\n</pre> meas_sigma_y/sim_sigma_y Out[25]: <pre>1.000599958804349</pre> In\u00a0[26]: Copied! <pre>im.proc_image\n</pre> im.proc_image Out[26]: <pre>array([[ 8, 30,  3, ..., 49, 25, 33],\n       [ 2, 11, 42, ..., 13, 45, 37],\n       [26, 39, 41, ..., 13, 46, 29],\n       ...,\n       [15, 37, 40, ..., 14, 31, 21],\n       [48, 46,  1, ...,  5, 23, 29],\n       [ 2, 15, 12, ..., 13, 44, 33]], dtype=int16)</pre>"},{"location":"examples/simulated_quad_scan/#simulated-quad-scan","title":"Simulated Quad Scan\u00b6","text":"<p>This will show a simple 'simulation' of a quadrupole scan of a beam to a screen.</p> <p>This assumes that the system consists of a thick quadrupole maget followed by an uncoupled linear transport map that the user provides. Here we will just use a 2.2 m long drift.</p>"},{"location":"examples/simulated_quad_scan/#simulation","title":"Simulation\u00b6","text":""},{"location":"examples/simulated_quad_scan/#measurements","title":"Measurements\u00b6","text":""},{"location":"examples/simulated_quad_scan/#make-the-data","title":"Make the data\u00b6","text":""},{"location":"examples/simulated_quad_scan/#emittance-calculation","title":"Emittance calculation\u00b6","text":""},{"location":"examples/simulated_quad_scan/#image-analysis","title":"Image Analysis\u00b6","text":"<p>PyEmittance has its own image analysis tools. Let's check these.</p>"},{"location":"examples/simulated_screen/","title":"Simulated Screen","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pyemittance.load_json_configs import load_configs\n</pre> import matplotlib.pyplot as plt import numpy as np  from pyemittance.load_json_configs import load_configs In\u00a0[3]: Copied! <pre>CONFIG = load_configs('LCLS2_OTR0H04')\nCONFIG.keys()\n</pre> CONFIG = load_configs('LCLS2_OTR0H04') CONFIG.keys() Out[3]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[4]: Copied! <pre>CONFIG['meas_pv_info']\n</pre> CONFIG['meas_pv_info'] Out[4]: <pre>{'diagnostic': {'pv': {'name': 'OTRS:HTR:330',\n   'image': 'OTRS:HTR:330:Image:ArrayData',\n   'nrow': 'OTRS:HTR:330:Image:ArraySize1_RBV',\n   'ncol': 'OTRS:HTR:330:Image:ArraySize0_RBV',\n   'resolution': 'OTRS:HTR:330:RESOLUTION',\n   'xsize': 'OTRS:HTR:330:XRMS',\n   'ysize': 'OTRS:HTR:330:YRMS'}},\n 'meas_device': {'settle_time': 1,\n  'bounds': [-2, 2],\n  'pv': {'name': 'QUAD:HTR:120',\n   'cntrl': 'QUAD:HTR:120:BCTRL',\n   'read': 'QUAD:HTR:120:BACT'}},\n 'beam_info': {'energy': ''}}</pre> In\u00a0[5]: Copied! <pre>from pyemittance.simulation import Screen\n</pre> from pyemittance.simulation import Screen In\u00a0[6]: Copied! <pre>S = Screen(noise=50)\nbg = S.background()\nplt.imshow(bg, vmax=128)\n</pre> S = Screen(noise=50) bg = S.background() plt.imshow(bg, vmax=128) Out[6]: <pre>&lt;matplotlib.image.AxesImage at 0x7f9b85b15370&gt;</pre> In\u00a0[7]: Copied! <pre>s = S.spot(mean_x = 0, mean_y = -.001, total_charge=100e-12,\n           sigma_x = 0.00001,\n           sigma_y = 0.000530470,\n          n_particle=100_000\n          )\nplt.imshow(s+bg, vmax=128), s.std(), np.sum(s), s.max()\n</pre> s = S.spot(mean_x = 0, mean_y = -.001, total_charge=100e-12,            sigma_x = 0.00001,            sigma_y = 0.000530470,           n_particle=100_000           ) plt.imshow(s+bg, vmax=128), s.std(), np.sum(s), s.max() Out[7]: <pre>(&lt;matplotlib.image.AxesImage at 0x7f9b859eb1c0&gt;,\n 130.44348154509655,\n 9785733,\n 6600)</pre> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots()\nax.imshow(s + bg, extent=1e3*np.array([S.xmin, S.xmax, S.ymin, S.ymax]), vmax=128)\nax.set_xlabel('x (mm)')\nax.set_ylabel('y (mm)')\n</pre> fig, ax = plt.subplots() ax.imshow(s + bg, extent=1e3*np.array([S.xmin, S.xmax, S.ymin, S.ymax]), vmax=128) ax.set_xlabel('x (mm)') ax.set_ylabel('y (mm)') Out[8]: <pre>Text(0, 0.5, 'y (mm)')</pre>"},{"location":"examples/simulated_screen/#simulated-screen","title":"Simulated Screen\u00b6","text":""},{"location":"examples/simulated_screen/#blank-screen","title":"Blank Screen\u00b6","text":""},{"location":"examples/simulated_screen/#screen-with-spot","title":"Screen with spot\u00b6","text":""},{"location":"examples/old/lcls_optimizer/","title":"Lcls optimizer","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport datetime\n</pre> import numpy as np import datetime In\u00a0[\u00a0]: Copied! <pre>from bayes_opt import BayesianOptimization, UtilityFunction\nfrom scipy import optimize\n</pre> from bayes_opt import BayesianOptimization, UtilityFunction from scipy import optimize In\u00a0[\u00a0]: Copied! <pre>from pyemittance.pyemittance import eval_emit_machine\n</pre> from pyemittance.pyemittance import eval_emit_machine In\u00a0[\u00a0]: Copied! <pre>class Opt:\n    def __init__(self, init_scan=[-6, -4, -2, 0]):\n        self.varscan = init_scan\n        self.num_points_adapt = 7\n        self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))\n        self.plot = False\n        self.save_runs = False\n        self.online = False\n        self.uncertainty_lim = 0.25\n        self.timestamp = None\n        self.total_num_points = 0\n        self.seed = 12\n\n    def evaluate(self, varx, vary, varz):\n        # fixed initial varscan\n        quad_init = self.varscan\n        config = [varx, vary, varz]\n\n        out_dict, self.total_num_points = eval_emit_machine(config,\n                                                       quad_init=list(quad_init),\n                                                       online=self.online,\n                                                       name='LCLS',\n                                                       meas_type='OTRS',\n                                                       adapt_ranges=True,\n                                                       num_points=self.num_points_adapt,\n                                                       check_sym=True,\n                                                       infl_check=True,\n                                                       add_pnts=True,\n                                                       show_plots=self.plot,\n                                                       use_prev_meas=True,\n                                                       quad_tol=0.02,\n                                                       save_runs=self.save_runs,\n                                                       calc_bmag=True)\n\n        return out_dict\n\n    def evaluate_bo(self, varx, vary, varz):\n        out_dict = self.evaluate(varx, vary, varz)\n\n        emit = out_dict['nemit']\n        emit_err = out_dict['nemit_err']\n\n        if np.isnan(emit):\n            print(\"NaN emit\")\n            return np.nan, np.nan\n\n        if emit_err / emit &lt; self.uncertainty_lim:\n            # save total number of points added\n            timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n            f = open(f\"bo_points_meas_iter.txt\", \"a+\")\n            f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')\n            f.close()\n\n        return -emit, -emit_err\n\n    def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=120):\n        np.random.seed(self.seed)\n\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=None,\n            pbounds=bounds,\n            random_state=rnd_state,\n            verbose=2\n        )\n\n        # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)\n        utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)\n\n        target_list = []\n\n        # init random points\n        x = []\n        emit_list = []\n        emit_err_list = []\n\n        emit_res = (np.nan, np.nan)\n        while len(emit_list) &lt; init_pnts:\n            x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n                   np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n                   np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]\n            emit_res = self.evaluate(x_i[0], x_i[1], x_i[2])\n\n            if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):# and abs(emit_res[0]) &gt; 58e-8:\n                # take large init emittances\n                x.append(x_i)\n                emit_list.append(emit_res[0])\n                emit_err_list.append(emit_res[1])\n\n        print(\"Init configs: \", x)\n        print(\"Init emit: \", emit_list)\n        # get init points\n        for i in range(len(x)):\n            # target, error = np.nan, np.nan\n            # hile np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:\n            next_point = {'varx': x[i][0],\n                          'vary': x[i][1],\n                          'varz': x[i][2]\n                          }\n            #                 # evaluate next point\n            target = emit_list[i]\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f} \"\n                f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            target_list.append(target)\n\n        # BO iters\n        for i in range(n_iter):\n            target, error = np.nan, np.nan\n            while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:\n                next_point = optimizer.suggest(utility)\n                target, error = self.evaluate(**next_point)\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f}\"\n                f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            emit_list.append(target)\n            emit_err_list.append(error)\n            target_list.append(target)\n\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_list,\n                allow_pickle=True)\n        np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_err_list,\n                allow_pickle=True)\n        np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', optimizer.res,\n                allow_pickle=True)\n\n        return optimizer\n\n    def eval_simplex(self, x):\n        out_dict = self.evaluate(x[0], x[1], x[2])\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        emit = out_dict['nemit']\n        err = out_dict['nemit_err']\n        \n        if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):\n            print(\"NaN or high uncertainty emittance, returning 100.\")\n            f = open(f\"simplex_run.txt\", \"a+\")\n            f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')\n            f.close()\n            return 100\n\n        f = open(f\"simplex_run.txt\", \"a+\")\n        f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')\n        f.close()\n\n        return emit\n\n    def run_simplex_opt(self, max_iter):\n\n        np.random.seed(self.seed)\n\n        initial_guess = np.array(\n            [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ])\n\n        # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])\n        # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])\n        # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])\n\n        # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])\n\n        min = optimize.minimize(self.eval_simplex, initial_guess,\n                                method='Nelder-Mead', options={'maxiter': max_iter,\n                                                               'return_all': True,\n                                                               'adaptive': True,\n                                                               'fatol': 0.1 * 0.75,\n                                                               'xatol': 0.00001\n                                                               },\n                                )\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n        np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)\n\n        f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")\n        f.write(min)\n        f.close()\n\n        return min\n\n    def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=self.evaluate,\n            pbounds=bounds,\n            random_state=rnd_state,\n        )\n\n        #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)\n        optimizer.maximize(init_points=init_pnts,\n                           n_iter=n_iter,\n                           kappa=0.01\n                           # kappa_decay = 0.8,\n                           # kappa_decay_delay = 25\n                           )\n\n        return optimizer\n\n    def run_simplex_opt_norm(self, max_iter):\n        np.random.seed(self.seed)\n\n        # below code based on Badger implementation of simplex for the ACR\n\n        # vars init values\n        x0 = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ]\n        # lower bounds\n        lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]\n        # upper bounds\n        ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]\n        # normalization coeff\n        gain = 4\n        # tolerance\n        xtol = 1e-9\n\n        # Convert (possible) list to array\n        x0 = np.array(x0)\n        lb = np.array(lb)\n        ub = np.array(ub)\n\n        x0_raw = lb + x0 * (ub - lb)\n        mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))\n        sigma = np.sqrt(np.abs(mu))\n\n        x0_n = (x0_raw - mu) / sigma  # normalized x0\n\n        def _evaluate(x_n):\n            x_n = np.array(x_n)\n            x_raw = mu + sigma * x_n  # denormalization from Ocelot\n            x = (x_raw - lb) / (ub - lb)  # normalization for Badger\n            y = self.eval_simplex(x)\n\n            return y\n\n        res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,\n                            full_output=True)\n\n        print(res)\n\n        return res\n</pre> class Opt:     def __init__(self, init_scan=[-6, -4, -2, 0]):         self.varscan = init_scan         self.num_points_adapt = 7         self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))         self.plot = False         self.save_runs = False         self.online = False         self.uncertainty_lim = 0.25         self.timestamp = None         self.total_num_points = 0         self.seed = 12      def evaluate(self, varx, vary, varz):         # fixed initial varscan         quad_init = self.varscan         config = [varx, vary, varz]          out_dict, self.total_num_points = eval_emit_machine(config,                                                        quad_init=list(quad_init),                                                        online=self.online,                                                        name='LCLS',                                                        meas_type='OTRS',                                                        adapt_ranges=True,                                                        num_points=self.num_points_adapt,                                                        check_sym=True,                                                        infl_check=True,                                                        add_pnts=True,                                                        show_plots=self.plot,                                                        use_prev_meas=True,                                                        quad_tol=0.02,                                                        save_runs=self.save_runs,                                                        calc_bmag=True)          return out_dict      def evaluate_bo(self, varx, vary, varz):         out_dict = self.evaluate(varx, vary, varz)          emit = out_dict['nemit']         emit_err = out_dict['nemit_err']          if np.isnan(emit):             print(\"NaN emit\")             return np.nan, np.nan          if emit_err / emit &lt; self.uncertainty_lim:             # save total number of points added             timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")             f = open(f\"bo_points_meas_iter.txt\", \"a+\")             f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')             f.close()          return -emit, -emit_err      def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=120):         np.random.seed(self.seed)          # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=None,             pbounds=bounds,             random_state=rnd_state,             verbose=2         )          # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)         utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)          target_list = []          # init random points         x = []         emit_list = []         emit_err_list = []          emit_res = (np.nan, np.nan)         while len(emit_list) &lt; init_pnts:             x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),                    np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),                    np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]             emit_res = self.evaluate(x_i[0], x_i[1], x_i[2])              if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):# and abs(emit_res[0]) &gt; 58e-8:                 # take large init emittances                 x.append(x_i)                 emit_list.append(emit_res[0])                 emit_err_list.append(emit_res[1])          print(\"Init configs: \", x)         print(\"Init emit: \", emit_list)         # get init points         for i in range(len(x)):             # target, error = np.nan, np.nan             # hile np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:             next_point = {'varx': x[i][0],                           'vary': x[i][1],                           'varz': x[i][2]                           }             #                 # evaluate next point             target = emit_list[i]              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f} \"                 f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             target_list.append(target)          # BO iters         for i in range(n_iter):             target, error = np.nan, np.nan             while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:                 next_point = optimizer.suggest(utility)                 target, error = self.evaluate(**next_point)              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target/1e-6:.3f} | config {next_point['varx']:.6f}\"                 f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             emit_list.append(target)             emit_err_list.append(error)             target_list.append(target)          timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_list,                 allow_pickle=True)         np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', emit_err_list,                 allow_pickle=True)         np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy', optimizer.res,                 allow_pickle=True)          return optimizer      def eval_simplex(self, x):         out_dict = self.evaluate(x[0], x[1], x[2])         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          emit = out_dict['nemit']         err = out_dict['nemit_err']                  if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):             print(\"NaN or high uncertainty emittance, returning 100.\")             f = open(f\"simplex_run.txt\", \"a+\")             f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')             f.close()             return 100          f = open(f\"simplex_run.txt\", \"a+\")         f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')         f.close()          return emit      def run_simplex_opt(self, max_iter):          np.random.seed(self.seed)          initial_guess = np.array(             [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ])          # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])         # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])         # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])          # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])          min = optimize.minimize(self.eval_simplex, initial_guess,                                 method='Nelder-Mead', options={'maxiter': max_iter,                                                                'return_all': True,                                                                'adaptive': True,                                                                'fatol': 0.1 * 0.75,                                                                'xatol': 0.00001                                                                },                                 )         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")         np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)          f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")         f.write(min)         f.close()          return min      def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):         # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=self.evaluate,             pbounds=bounds,             random_state=rnd_state,         )          #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)         optimizer.maximize(init_points=init_pnts,                            n_iter=n_iter,                            kappa=0.01                            # kappa_decay = 0.8,                            # kappa_decay_delay = 25                            )          return optimizer      def run_simplex_opt_norm(self, max_iter):         np.random.seed(self.seed)          # below code based on Badger implementation of simplex for the ACR          # vars init values         x0 = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ]         # lower bounds         lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]         # upper bounds         ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]         # normalization coeff         gain = 4         # tolerance         xtol = 1e-9          # Convert (possible) list to array         x0 = np.array(x0)         lb = np.array(lb)         ub = np.array(ub)          x0_raw = lb + x0 * (ub - lb)         mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))         sigma = np.sqrt(np.abs(mu))          x0_n = (x0_raw - mu) / sigma  # normalized x0          def _evaluate(x_n):             x_n = np.array(x_n)             x_raw = mu + sigma * x_n  # denormalization from Ocelot             x = (x_raw - lb) / (ub - lb)  # normalization for Badger             y = self.eval_simplex(x)              return y          res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,                             full_output=True)          print(res)          return res"},{"location":"examples/old/sim_optimizer/","title":"Sim optimizer","text":"In\u00a0[\u00a0]: Copied! <pre>from argparse import Namespace\nimport datetime\nimport numpy as np\nfrom bayes_opt import BayesianOptimization, UtilityFunction\nfrom scipy import optimize\n</pre> from argparse import Namespace import datetime import numpy as np from bayes_opt import BayesianOptimization, UtilityFunction from scipy import optimize In\u00a0[\u00a0]: Copied! <pre>from pyemittance.emit_eval_example import eval_emit_surrogate\nfrom lcls_functions import Lcls\n</pre> from pyemittance.emit_eval_example import eval_emit_surrogate from lcls_functions import Lcls In\u00a0[\u00a0]: Copied! <pre>class Opt:\n    def __init__(self, init_scan=np.linspace(-6, 0, 4), bsfn=None):\n        self.varscan = init_scan\n        self.num_points_adapt = 7\n        self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))\n        self.plot = False\n        self.bsfn = None\n        self.uncertainty_lim = 0.25\n        self.timestamp = None\n        self.noise = False\n        if bsfn is None:\n            bsfn = self.get_default_bsfn()\n        self.bsfn = bsfn\n        self.total_num_points = 0\n        self.seed = 12\n\n    def get_default_bsfn(self):\n        lcls_params = Namespace(\n            config_bounds=[(self.pbounds[0][0], self.pbounds[0][1]),\n                           (self.pbounds[1][0], self.pbounds[1][1]),\n                           (self.pbounds[2][0], self.pbounds[2][1])],\n            quad_bounds=(-6.0, 0.0),\n            beamsizes_bounds=[(0.0, 5e-4), (0.0, 5e-4)],\n        )\n        lcls = Lcls(params=lcls_params)\n        bsfn = lcls.beamsizes_list_fn\n        return bsfn\n\n    def get_beamsizes_model(self, config, val):\n        beamsizes_list = self.bsfn(config, [val], verbose=False)[0]\n        xrms = beamsizes_list[0]\n        yrms = beamsizes_list[1]\n        xrms_err = xrms * 0.03\n        yrms_err = yrms * 0.03\n        return xrms, yrms, xrms_err, yrms_err\n\n    def evaluate(self, varx, vary, varz):\n        # fixed varscan\n        quad_init = self.varscan\n        config = [varx, vary, varz]\n\n        out_dict, self.total_num_points = eval_emit_surrogate(\n            self.get_beamsizes_model,\n            config,\n            quad_init=list(quad_init),\n            adapt_ranges=True,\n            num_points=self.num_points_adapt,\n            check_sym=True,\n            infl_check=True,\n            add_pnts=True,\n            show_plots=self.plot,\n            add_noise=self.noise,\n        )\n\n        return out_dict\n\n    def evaluate_bo(self, varx, vary, varz):\n        out_dict = self.evaluate(varx, vary, varz)\n\n        emit = out_dict['nemit']\n        emit_err = out_dict['nemit_err']\n\n        if np.isnan(emit):\n            print(\"NaN emit\")\n            return np.nan, np.nan\n\n        if emit_err / emit &lt; self.uncertainty_lim:\n            # save total number of points added\n            timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n            f = open(f\"bo_noisy_seed_{self.seed}.txt\", \"a+\")\n            f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')\n            f.close()\n\n        return -emit, -emit_err\n\n    def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=200):\n        np.random.seed(self.seed)\n\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=None,\n            pbounds=bounds,\n            random_state=rnd_state,\n            verbose=2\n        )\n\n        # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)\n        utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)\n\n        target_list = []\n\n        # init random points\n        x = []\n        emit_list = []\n        emit_err_list = []\n\n        emit_res = (np.nan, np.nan)\n        while len(emit_list) &lt; init_pnts:\n            x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n                   np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n                   np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]\n            emit_res = self.evaluate_bo(x_i[0], x_i[1], x_i[2])\n\n            if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):  # and abs(emit_res[0]) &gt; 1.0:\n                x.append(x_i)\n                emit_list.append(emit_res[0])\n                emit_err_list.append(emit_res[1])\n\n        # get init points\n        for i in range(len(x)):\n            # target, error = np.nan, np.nan\n            #             while np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:\n            next_point = {'varx': x[i][0],\n                          'vary': x[i][1],\n                          'varz': x[i][2]\n                          }\n            #                 # evaluate next point\n            target = emit_list[i]\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f}\"\n                f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            target_list.append(target)\n\n        # BO iters\n        for i in range(n_iter):\n            target, error = np.nan, np.nan\n            while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:\n                next_point = optimizer.suggest(utility)\n                target, error = self.evaluate_bo(**next_point)\n\n            optimizer.register(params=next_point, target=target)\n            if target_list and target &gt; np.max(target_list):\n                color = '\\033[95m', '\\033[0m'\n            else:\n                color = '\\u001b[30m', '\\033[0m'\n\n            print(\n                f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f} \"\n                f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")\n            emit_list.append(target)\n            emit_err_list.append(error)\n            target_list.append(target)\n\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                emit_list, allow_pickle=True)\n        np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                emit_err_list, allow_pickle=True)\n        np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',\n                optimizer.res, allow_pickle=True)\n\n        return optimizer\n\n    def eval_simplex(self, x):\n        out_dict = self.evaluate(x[0], x[1], x[2])\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n\n        emit = out_dict['nemit']\n        err = out_dict['nemit_err']\n\n        if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):\n            print(\"NaN emit\")\n            f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")\n            f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')\n            f.close()\n            return 100\n\n        f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")\n        f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')\n        f.close()\n\n        return emit\n\n    def run_simplex_opt(self, max_iter):\n\n        np.random.seed(self.seed)\n\n        initial_guess = np.array(\n            [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),\n             np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),\n             np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])\n             ])\n\n        # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])\n        # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])\n        # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])\n\n        # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])\n\n        min = optimize.minimize(self.eval_simplex, initial_guess,\n                                method='Nelder-Mead', options={'maxiter': max_iter,\n                                                               'return_all': True,\n                                                               'adaptive': True,\n                                                               'fatol': 0.1 * 0.75,\n                                                               'xatol': 0.00001\n                                                               },\n                                )\n        timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")\n        np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)\n\n        f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")\n        f.write(min)\n        f.close()\n\n        return min\n\n    def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):\n        # Set domain\n        bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}\n\n        # Run BO\n        optimizer = BayesianOptimization(\n            f=self.evaluate,\n            pbounds=bounds,\n            random_state=rnd_state,\n        )\n\n        #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)\n        optimizer.maximize(init_points=init_pnts,\n                           n_iter=n_iter,\n                           kappa=0.01\n                           # kappa_decay = 0.8,\n                           # kappa_decay_delay = 25\n                           )\n\n        return optimizer\n\n    def run_simplex_opt_norm(self, max_iter):\n        np.random.seed(self.seed)\n\n        # below code based on Badger implementation of simplex for the ACR\n\n        # vars init values\n        # x0 = [0.46875, (self.pbounds[1][0] + self.pbounds[1][1]) / 2, (self.pbounds[2][0] + self.pbounds[2][1]) / 2]\n        # ref point from sim\n        x0 = [0.4779693455075814, -0.001499227120199691, -0.0006872989433749197]\n        # lower bounds\n        lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]\n        # upper bounds\n        ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]\n        # normalization coeff\n        gain = 1.8\n        # tolerance\n        xtol = 1e-9\n\n        # Convert (possible) list to array\n        x0 = np.array(x0)\n        lb = np.array(lb)\n        ub = np.array(ub)\n\n        x0_raw = lb + x0 * (ub - lb)\n        mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))\n        sigma = np.sqrt(np.abs(mu))\n\n        x0_n = (x0_raw - mu) / sigma  # normalized x0\n\n        def _evaluate(x_n):\n            x_n = np.array(x_n)\n            x_raw = mu + sigma * x_n  # denormalization from Ocelot\n            x = (x_raw - lb) / (ub - lb)  # normalization for Badger\n            y = self.eval_simplex(x)\n\n            return y\n\n        res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,\n                            full_output=True)\n\n        print(res)\n\n        return res\n</pre> class Opt:     def __init__(self, init_scan=np.linspace(-6, 0, 4), bsfn=None):         self.varscan = init_scan         self.num_points_adapt = 7         self.pbounds = ((0.46, 0.485), (-0.01, 0.01), (-0.01, 0.01))         self.plot = False         self.bsfn = None         self.uncertainty_lim = 0.25         self.timestamp = None         self.noise = False         if bsfn is None:             bsfn = self.get_default_bsfn()         self.bsfn = bsfn         self.total_num_points = 0         self.seed = 12      def get_default_bsfn(self):         lcls_params = Namespace(             config_bounds=[(self.pbounds[0][0], self.pbounds[0][1]),                            (self.pbounds[1][0], self.pbounds[1][1]),                            (self.pbounds[2][0], self.pbounds[2][1])],             quad_bounds=(-6.0, 0.0),             beamsizes_bounds=[(0.0, 5e-4), (0.0, 5e-4)],         )         lcls = Lcls(params=lcls_params)         bsfn = lcls.beamsizes_list_fn         return bsfn      def get_beamsizes_model(self, config, val):         beamsizes_list = self.bsfn(config, [val], verbose=False)[0]         xrms = beamsizes_list[0]         yrms = beamsizes_list[1]         xrms_err = xrms * 0.03         yrms_err = yrms * 0.03         return xrms, yrms, xrms_err, yrms_err      def evaluate(self, varx, vary, varz):         # fixed varscan         quad_init = self.varscan         config = [varx, vary, varz]          out_dict, self.total_num_points = eval_emit_surrogate(             self.get_beamsizes_model,             config,             quad_init=list(quad_init),             adapt_ranges=True,             num_points=self.num_points_adapt,             check_sym=True,             infl_check=True,             add_pnts=True,             show_plots=self.plot,             add_noise=self.noise,         )          return out_dict      def evaluate_bo(self, varx, vary, varz):         out_dict = self.evaluate(varx, vary, varz)          emit = out_dict['nemit']         emit_err = out_dict['nemit_err']          if np.isnan(emit):             print(\"NaN emit\")             return np.nan, np.nan          if emit_err / emit &lt; self.uncertainty_lim:             # save total number of points added             timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")             f = open(f\"bo_noisy_seed_{self.seed}.txt\", \"a+\")             f.write(f'{varx},{vary},{varz},{emit},{emit_err},{self.total_num_points},{timestamp}\\n')             f.close()          return -emit, -emit_err      def run_bo_opt_w_reject(self, rnd_state=11, init_pnts=3, n_iter=200):         np.random.seed(self.seed)          # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=None,             pbounds=bounds,             random_state=rnd_state,             verbose=2         )          # utility = UtilityFunction(kind=\"ucb\", kappa=0.1, xi=0.0)         utility = UtilityFunction(kind=\"ucb\", kappa=2.5, xi=0.0)          target_list = []          # init random points         x = []         emit_list = []         emit_err_list = []          emit_res = (np.nan, np.nan)         while len(emit_list) &lt; init_pnts:             x_i = [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),                    np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),                    np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])]             emit_res = self.evaluate_bo(x_i[0], x_i[1], x_i[2])              if not np.isnan(emit_res[0]) and not np.isnan(emit_res[1]):  # and abs(emit_res[0]) &gt; 1.0:                 x.append(x_i)                 emit_list.append(emit_res[0])                 emit_err_list.append(emit_res[1])          # get init points         for i in range(len(x)):             # target, error = np.nan, np.nan             #             while np.isnan(target) or np.isnan(error) or error/target &gt; self.uncertainty_lim:             next_point = {'varx': x[i][0],                           'vary': x[i][1],                           'varz': x[i][2]                           }             #                 # evaluate next point             target = emit_list[i]              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f}\"                 f\" {next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             target_list.append(target)          # BO iters         for i in range(n_iter):             target, error = np.nan, np.nan             while np.isnan(target) or np.isnan(error) or error / target &gt; self.uncertainty_lim:                 next_point = optimizer.suggest(utility)                 target, error = self.evaluate_bo(**next_point)              optimizer.register(params=next_point, target=target)             if target_list and target &gt; np.max(target_list):                 color = '\\033[95m', '\\033[0m'             else:                 color = '\\u001b[30m', '\\033[0m'              print(                 f\"{color[0]}iter {i} | target {-1 * target / 1e-6:.3f} | config {next_point['varx']:.6f} \"                 f\"{next_point['vary']:.6f} {next_point['varz']:.6f}{color[1]}\")             emit_list.append(target)             emit_err_list.append(error)             target_list.append(target)          timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          np.save(f'bo_opt_res_emit_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 emit_list, allow_pickle=True)         np.save(f'bo_opt_res_emit_err_list_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 emit_err_list, allow_pickle=True)         np.save(f'bo_opt_res_{rnd_state}_{init_pnts}_{n_iter}_{timestamp}.npy',                 optimizer.res, allow_pickle=True)          return optimizer      def eval_simplex(self, x):         out_dict = self.evaluate(x[0], x[1], x[2])         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")          emit = out_dict['nemit']         err = out_dict['nemit_err']          if np.isnan(emit) or (err / emit &gt; self.uncertainty_lim):             print(\"NaN emit\")             f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")             f.write(f'{x[0]},{x[1]},{x[2]},{np.nan},{np.nan},{self.total_num_points},{timestamp}\\n')             f.close()             return 100          f = open(f\"simplex_noisy_seed_{self.seed}.txt\", \"a+\")         f.write(f'{x[0]},{x[1]},{x[2]},{emit},{err},{self.total_num_points},{timestamp}\\n')         f.close()          return emit      def run_simplex_opt(self, max_iter):          np.random.seed(self.seed)          initial_guess = np.array(             [np.random.uniform(self.pbounds[0][0], self.pbounds[0][1]),              np.random.uniform(self.pbounds[1][0], self.pbounds[1][1]),              np.random.uniform(self.pbounds[2][0], self.pbounds[2][1])              ])          # initial_guess1 = self.pbounds[0][0]+ np.random.rand(1) * (self.pbounds[0][1] - self.pbounds[0][0])         # initial_guess2 = self.pbounds[1][0]+ np.random.rand(1) * (self.pbounds[1][1] - self.pbounds[1][0])         # initial_guess3 = self.pbounds[2][0]+ np.random.rand(1) * (self.pbounds[2][1] - self.pbounds[2][0])          # initial_guess = np.array([initial_guess1, initial_guess2, initial_guess3])          min = optimize.minimize(self.eval_simplex, initial_guess,                                 method='Nelder-Mead', options={'maxiter': max_iter,                                                                'return_all': True,                                                                'adaptive': True,                                                                'fatol': 0.1 * 0.75,                                                                'xatol': 0.00001                                                                },                                 )         timestamp = (datetime.datetime.now()).strftime(\"%Y-%m-%d_%H-%M-%S\")         np.save(f'simplex_allvecs_{timestamp}.npy', min[\"allvecs\"], allow_pickle=True)          f = open(f\"simplex_allres_{timestamp}.txt\", \"a+\")         f.write(min)         f.close()          return min      def run_bo_opt(self, rnd_state=11, init_pnts=3, n_iter=200):         # Set domain         bounds = {'varx': self.pbounds[0], 'vary': self.pbounds[1], 'varz': self.pbounds[2]}          # Run BO         optimizer = BayesianOptimization(             f=self.evaluate,             pbounds=bounds,             random_state=rnd_state,         )          #        optimizer.maximize(init_points=init_pnts, n_iter=n_iter)         optimizer.maximize(init_points=init_pnts,                            n_iter=n_iter,                            kappa=0.01                            # kappa_decay = 0.8,                            # kappa_decay_delay = 25                            )          return optimizer      def run_simplex_opt_norm(self, max_iter):         np.random.seed(self.seed)          # below code based on Badger implementation of simplex for the ACR          # vars init values         # x0 = [0.46875, (self.pbounds[1][0] + self.pbounds[1][1]) / 2, (self.pbounds[2][0] + self.pbounds[2][1]) / 2]         # ref point from sim         x0 = [0.4779693455075814, -0.001499227120199691, -0.0006872989433749197]         # lower bounds         lb = [self.pbounds[0][0], self.pbounds[1][0], self.pbounds[2][0]]         # upper bounds         ub = [self.pbounds[0][1], self.pbounds[1][1], self.pbounds[2][1]]         # normalization coeff         gain = 1.8         # tolerance         xtol = 1e-9          # Convert (possible) list to array         x0 = np.array(x0)         lb = np.array(lb)         ub = np.array(ub)          x0_raw = lb + x0 * (ub - lb)         mu = x0_raw - gain * np.sqrt(np.abs(x0_raw))         sigma = np.sqrt(np.abs(mu))          x0_n = (x0_raw - mu) / sigma  # normalized x0          def _evaluate(x_n):             x_n = np.array(x_n)             x_raw = mu + sigma * x_n  # denormalization from Ocelot             x = (x_raw - lb) / (ub - lb)  # normalization for Badger             y = self.eval_simplex(x)              return y          res = optimize.fmin(_evaluate, x0_n, maxiter=max_iter, maxfun=max_iter, xtol=xtol, retall=True,                             full_output=True)          print(res)          return res"},{"location":"examples/old/tutorial/","title":"PyEmittance Tutorial","text":"In\u00a0[1]: Copied! <pre>from pyemittance import PyEmittance\nimport numpy as np\n</pre> from pyemittance import PyEmittance import numpy as np In\u00a0[2]: Copied! <pre>meas = PyEmittance()\n</pre> meas = PyEmittance() <pre>No settle_time found in in meas_device, setting to zero\n</pre> In\u00a0[3]: Copied! <pre>meas.config_name\n</pre> meas.config_name Out[3]: <pre>'LCLS_OTR2'</pre> In\u00a0[4]: Copied! <pre>meas.num_points = 5\n</pre> meas.num_points = 5 In\u00a0[5]: Copied! <pre># see all configs with command below\nmeas.config_dict.keys()\n</pre> # see all configs with command below meas.config_dict.keys() Out[5]: <pre>dict_keys(['beamline_info', 'img_proc', 'meas_pv_info', 'savepaths'])</pre> In\u00a0[6]: Copied! <pre>meas.config_dict['img_proc']\n</pre> meas.config_dict['img_proc'] Out[6]: <pre>{'subtract_bg': False,\n 'use_roi': False,\n 'avg_ims': True,\n 'n_to_acquire': 5,\n 'background_im': None,\n 'amp_threshold': 1500,\n 'min_sigma': 1.0,\n 'max_sigma': 60,\n 'max_samples': 3,\n 'roi': {'xmin': 0, 'xmax': 100, 'ymin': 0, 'ymax': 100}}</pre> In\u00a0[7]: Copied! <pre>meas.quad_init\n</pre> meas.quad_init Out[7]: <pre>[-6, -4, -2, 0]</pre> In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nres = meas.measure_emittance()\n</pre> import matplotlib.pyplot as plt res = meas.measure_emittance() <pre>No settle_time found in in meas_device, setting to zero\nEmittance can't be computed. Returning error\n</pre> <pre>[None]\n[None, None]\n[None, None, None]\n[None, None, None, None]\n</pre> In\u00a0[9]: Copied! <pre>meas.config_dict['beamline_info']\n</pre> meas.config_dict['beamline_info'] Out[9]: <pre>{'name': 'LCLS',\n 'Lquad': 0.108,\n 'energy': 135000000.0,\n 'Twiss0': [1e-06,\n  1e-06,\n  1.113081026,\n  1.113021659,\n  -0.0689403587,\n  -0.07029489754],\n 'rMatx': [1, 2.26, 0, 1],\n 'rMaty': [1, 2.26, 0, 1]}</pre> <p>The output is a large dict:</p> In\u00a0[10]: Copied! <pre>res\n</pre> res Out[10]: <pre>{'quadvalsx': array([-5.6, -4.8, -4. , -3.5, -3. ]),\n 'beamsizesx': array([3.06341697e-04, 3.06273619e-04, 7.55905120e-05, 1.63444300e-04,\n        2.55702280e-04]),\n 'beamsizeserrx': array([4.59512546e-06, 4.59410428e-06, 1.13385768e-06, 2.45166450e-06,\n        3.83553420e-06]),\n 'error_x': False,\n 'emit_x': 1.3182016649832431e-08,\n 'norm_emit_x': 3.482511068194004e-06,\n 'beta_x': 15.02622785043927,\n 'alpha_x': 19.061745278330807,\n 'emit_x_err': 2.7117885883349793e-10,\n 'norm_emit_x_err': 7.164179824942649e-08,\n 'beta_x_rel_err': 0.020571879556718395,\n 'alpha_x_rel_err': 5.4078530536262715e-18,\n 'sigma_11': 1.9807598570866623e-07,\n 'sigma_12': -2.5127224363382145e-07,\n 'sigma_22': 3.19632416606275e-07,\n 'screen_sigma_11': array([1.14061440e-07, 2.84407799e-08, 6.02730207e-09, 2.35808867e-08,\n        6.50628711e-08]),\n 'screen_sigma_12': array([-9.81555058e-09, -1.49241525e-08,  7.07670009e-09,  3.43612956e-08,\n         7.19047215e-08]),\n 'screen_sigma_22': array([2.36811490e-09, 1.39411047e-08, 3.71385480e-08, 5.74390698e-08,\n        8.21367771e-08]),\n 'quadvalsy': array([0., 0., 0., 0., 0., 0., 0., 0., 0.]),\n 'beamsizesy': array([0.00030132, 0.00030132, 0.00030132, 0.00030132, 0.00030132,\n        0.00030132, 0.00030132, 0.00030132, 0.00030132]),\n 'beamsizeserry': array([4.51986378e-06, 4.51986378e-06, 4.51986378e-06, 4.51986378e-06,\n        4.51986378e-06, 4.51986378e-06, 4.51986378e-06, 4.51986378e-06,\n        4.51986378e-06]),\n 'error_y': True}</pre> In\u00a0[11]: Copied! <pre>meas.online = True\n</pre> meas.online = True In\u00a0[12]: Copied! <pre>try:\n    res = meas.measure_emittance()\nexcept:\n    pass # epics can't connect on my local pc\n</pre> try:     res = meas.measure_emittance() except:     pass # epics can't connect on my local pc <pre>No settle_time found in in meas_device, setting to zero\n</pre> <pre>cannot connect to OTRS:IN20:541:RESOLUTION\n</pre> In\u00a0[13]: Copied! <pre>def get_bs_model(*args):\n    return abs(np.random.normal(1e-6, 5e-5)), abs(np.random.normal(1e-6, 5e-6)), 0, 0\n\nget_bs_model()\n</pre> def get_bs_model(*args):     return abs(np.random.normal(1e-6, 5e-5)), abs(np.random.normal(1e-6, 5e-6)), 0, 0  get_bs_model() Out[13]: <pre>(4.626065606867356e-05, 2.9074184178285334e-06, 0, 0)</pre> In\u00a0[14]: Copied! <pre>meas.use_model=True\nmeas.online = False # meaningless when running with a model\nmeas.get_bs_model = get_bs_model\n</pre> meas.use_model=True meas.online = False # meaningless when running with a model meas.get_bs_model = get_bs_model In\u00a0[15]: Copied! <pre>res = meas.measure_emittance()\n</pre> res = meas.measure_emittance() <pre>No settle_time found in in meas_device, setting to zero\nEmittance can't be computed. Returning error\n</pre> <pre>[None]\n[None, None]\n[None, None, None]\n[None, None, None, None]\n</pre> In\u00a0[16]: Copied! <pre>res\n</pre> res Out[16]: <pre>{'quadvalsx': array([-3.48930477, -3.30405556, -3.21143095, -3.11880634, -2.88724483]),\n 'beamsizesx': array([0.00038239, 0.00015838, 0.00038971, 0.00017345, 0.0002698 ]),\n 'beamsizeserrx': array([5.73592306e-06, 2.37569589e-06, 5.84569223e-06, 2.60180711e-06,\n        4.04704389e-06]),\n 'error_x': False,\n 'emit_x': 1.004468402088881e-07,\n 'norm_emit_x': 2.6536700877025065e-05,\n 'beta_x': 25.950664792738966,\n 'alpha_x': 28.096185977648876,\n 'emit_x_err': 1.6077100516383735e-09,\n 'norm_emit_x_err': 4.2473531918566967e-07,\n 'beta_x_rel_err': 0.016005581144511442,\n 'alpha_x_rel_err': 5.323130046664583e-16,\n 'sigma_11': 2.606662279750669e-06,\n 'sigma_12': -2.822173103376099e-06,\n 'sigma_22': 3.059372384016785e-06,\n 'screen_sigma_11': array([8.16597358e-08, 3.19401106e-08, 2.36907653e-08, 2.64822055e-08,\n        8.16028235e-08]),\n 'screen_sigma_12': array([-1.23426475e-07, -4.71022034e-08, -1.81738048e-09,  4.82016338e-08,\n         1.93891175e-07]),\n 'screen_sigma_22': array([3.10111981e-07, 3.85351993e-07, 4.26025518e-07, 4.68728528e-07,\n        5.84334626e-07]),\n 'quadvalsy': array([-6., -6., -6., -6., -6., -6., -6., -6., -6.]),\n 'beamsizesy': array([0.000104, 0.000104, 0.000104, 0.000104, 0.000104, 0.000104,\n        0.000104, 0.000104, 0.000104]),\n 'beamsizeserry': array([1.5599743e-06, 1.5599743e-06, 1.5599743e-06, 1.5599743e-06,\n        1.5599743e-06, 1.5599743e-06, 1.5599743e-06, 1.5599743e-06,\n        1.5599743e-06]),\n 'error_y': True}</pre>"},{"location":"examples/old/tutorial/#pyemittance-tutorial","title":"PyEmittance Tutorial\u00b6","text":""},{"location":"examples/old/tutorial/#three-options-for-setting-configurations-for-measurements","title":"Three options for setting configurations for measurements:\u00b6","text":"<ol> <li>Make directory under <code>configs/</code> with Machine_Device_Name with all needed jsons (see <code>configs/LCLS2_OTR3</code>), and pass dir name to <code>meas.config_name</code></li> <li>Change params and configs through class attributes</li> <li>pass the dictionary to pyemittance (same keys and subkeys as <code>meas.config_dict</code> below)</li> </ol>"},{"location":"examples/old/tutorial/#example-running-offline-with-random-beam-size-numbers","title":"Example running offline with random beam size numbers\u00b6","text":""},{"location":"examples/old/tutorial/#example-running-online-do-not-run-on-machine","title":"Example running online (do not run on machine!)\u00b6","text":""},{"location":"examples/old/tutorial/#example-running-with-some-random-beamsize-model","title":"Example running with some random beamsize model\u00b6","text":""},{"location":"examples/old/tutorial/#can-be-any-simulation-just-need-to-pass-pyemittance-the-beamsize-fn","title":"(can be any simulation, just need to pass pyemittance the beamsize fn)\u00b6","text":""}]}